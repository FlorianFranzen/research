
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>4. Sequential Phragmén’s method. &#8212; Research at W3F</title>
    <link rel="stylesheet" href="../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/stylesheets/extra.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"], "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]], "processEscapes": true}, "HTML-CSS": {"fonts": ["TeX"]}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="5. A Phragmén-like Heuristic" href="5. A Phragmén-like Heuristic.html" />
    <link rel="prev" title="3. The maximin support problem" href="3. The maximin support problem.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=deep-orange data-md-color-accent=deep-orange>
  <svg class="md-svg">
    <defs data-children-count="0">
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448"
           id="__github">
        <path fill="currentColor"
              d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"></path>
      </svg>
    </defs>
  </svg>
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#polkadot/NPoS/4. Sequential Phragmén’s method" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../index.html" title="Research at W3F"
           class="md-header-nav__button md-logo">
          
              <img src="../../_static/w3f_logo.svg" height="26"
                   alt="Research at W3F logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">Research at W3F</span>
          <span class="md-header-nav__topic"> 4. Sequential Phragmén’s method. </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Research at W3F</a></li>
          <li class="md-tabs__item"><a href="../../polkadot.html" class="md-tabs__link">Polkadot</a></li>
          <li class="md-tabs__item"><a href="../NPoS.html" class="md-tabs__link">NPoS</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../index.html" title="Research at W3F" class="md-nav__button md-logo">
      
        <img src="../../_static/w3f_logo.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../index.html"
       title="Research at W3F">Research at W3F</a>
  </label>
  

  
  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <a href="../../polkadot.html" class="md-nav__link">Polkadot</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
      <a href="../index.html" class="md-nav__link">Polkadot</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../Availability_and_Validity.html" class="md-nav__link">Availability and Validity</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../GRANDPA.html" class="md-nav__link">GRANDPA</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../ICMP.html" class="md-nav__link">ICMP Scheme</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../Parachain-Allocation.html" class="md-nav__link">Parachain Allocation</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../Polkadot-Runtime-Environment.html" class="md-nav__link">Polkadot Runtime Environment Specification</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../Token Economics.html" class="md-nav__link">Token Economics</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../BABE.html" class="md-nav__link">BABE</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../NPoS.html" class="md-nav__link">NPoS</a>
      <ul class="md-nav__list"> 
    <li class="md-nav__item">
    
      <a href="index.html" class="md-nav__link">Intro to Nominated Proof-of-Stake</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="1. Overview.html" class="md-nav__link">1. Overview of results for the NPoS election problem</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="2. The min-norm max-flow problem.html" class="md-nav__link">2. The min-norm max-flow problem</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="3. The maximin support problem.html" class="md-nav__link">3. The maximin support problem</a>
      
    </li>
    <li class="md-nav__item">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    <label class="md-nav__link md-nav__link--active" for="__toc"> 4. Sequential Phragmén’s method. </label>
    
      <a href="#" class="md-nav__link md-nav__link--active">4. Sequential Phragmén’s method.</a>
      
        
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#polkadot-npos-4-sequential-phragmens-method--page-root" class="md-nav__link">4. Sequential Phragmén’s method.</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#-1.-notation" class="md-nav__link">1. Notation</a>
        </li>
        <li class="md-nav__item"><a href="#-2.-algorithm" class="md-nav__link">2. Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#-3.-axiomatic-properties" class="md-nav__link">3. Axiomatic properties</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../../_sources/polkadot/NPoS/4. Sequential Phragmén’s method.md.txt">Show Source</a> </li>

  </ul>
</nav><ul class="md-nav__list"> 
    <li class="md-nav__item">
    
      <a href="#-1.-notation" class="md-nav__link">1. Notation</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="#-2.-algorithm" class="md-nav__link">2. Algorithm</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="#-3.-axiomatic-properties" class="md-nav__link">3. Axiomatic properties</a>
      
    </li></ul>
    </li>
    <li class="md-nav__item">
    
      <a href="5. A Phragmén-like Heuristic.html" class="md-nav__link">5. A Phragmén-like Heuristic</a>
      
    </li></ul>
    </li>
    <li class="md-nav__item">
    
      <a href="../keys.html" class="md-nav__link">Keys</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../networking.html" class="md-nav__link">Networking</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../slashing.html" class="md-nav__link">Slashing</a>
      
    </li></ul>
    </li>
    <li class="md-nav__item">
    
      <a href="../../research_team_members.html" class="md-nav__link">Research Team Members</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../news.html" class="md-nav__link">News</a>
      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#polkadot-npos-4-sequential-phragmens-method--page-root" class="md-nav__link">4. Sequential Phragmén’s method.</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#-1.-notation" class="md-nav__link">1. Notation</a>
        </li>
        <li class="md-nav__item"><a href="#-2.-algorithm" class="md-nav__link">2. Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#-3.-axiomatic-properties" class="md-nav__link">3. Axiomatic properties</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../../_sources/polkadot/NPoS/4. Sequential Phragmén’s method.md.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  
<h1 id="polkadot-npos-4-sequential-phragmens-method--page-root">4. Sequential Phragmén’s method.<a class="headerlink" href="#polkadot-npos-4-sequential-phragmens-method--page-root" title="Permalink to this headline">¶</a></h1>
<p>This note outlines a multiwinner election method introduced by Edvard Phragmén in the 1890’s and specified as a sequential greedy algorithm by <a class="reference external" href="https://aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14757/13791">Brill et al. (2017)</a>, adapted to the problem of electing validators in Polkadot. In particular, we have adapted Brill et al.’s algorithm and proofs to the weighted case. </p>
<p><strong>Remark.</strong> No objective function is declared in this note. In particular, this algorithm offers no constant-factor approximation guarantee for the <a class="reference external" href="3. The maximin support problem.html">maximin support objective</a>.</p>
<p>We give needed notations in Section 1. In Section 2, we show that this algorithm runs in time 
<span class="math notranslate nohighlight">\(O(m|E|)\)</span></p>
<p>if each lookup and floating arithmetic operation is considered constant time, where <span class="math notranslate nohighlight">\(m\)</span> is the number of elected validators, and <span class="math notranslate nohighlight">\(|E|\)</span> is the number of edges in the nominator-validator relation graph. </p>
<p>In Section 3, we also show that the elected commitee observes the property of Proportional Justified Representation (PJR), a popular axiom in the area of election theory establishing that an election is “fair”.</p>

<h2 id="-1.-notation">1. Notation<a class="headerlink" href="#-1.-notation" title="Permalink to this headline">¶</a></h2>
<p>An instance of NPoS is given by a bipartite graph <span class="math notranslate nohighlight">\((N\cup V, E)\)</span>, where <span class="math notranslate nohighlight">\(nv\in E\)</span> represents the approval by nominator <span class="math notranslate nohighlight">\(n\in E\)</span> of candidate validator <span class="math notranslate nohighlight">\(v\)</span>, a vector of nominator budgets <span class="math notranslate nohighlight">\(b\in \mathbb{R}_{\geq 0}^N\)</span>, and the number <span class="math notranslate nohighlight">\(m\)</span> of candidate validators to be elected. We also denote by <span class="math notranslate nohighlight">\(V_n\subseteq V\)</span> the  set of candidates supported by nominator <span class="math notranslate nohighlight">\(n\)</span>, and by <span class="math notranslate nohighlight">\(N_v\subseteq N\)</span> the set of nominators that support validator <span class="math notranslate nohighlight">\(v\)</span>. </p>
<p>An election is given by the pair <span class="math notranslate nohighlight">\((S,w)\)</span> where <span class="math notranslate nohighlight">\(S\subseteq V\)</span> is a committee of <span class="math notranslate nohighlight">\(m\)</span> elected validators, and <span class="math notranslate nohighlight">\(w\in \mathbb{R}_{\geq 0}^E\)</span> is a vector of edge weights where <span class="math notranslate nohighlight">\(w_{nv}\)</span> represents the precise amount of stake that nominator <span class="math notranslate nohighlight">\(n\)</span> assigns to validator <span class="math notranslate nohighlight">\(v\)</span>. Besides non-negativity constraints, vector <span class="math notranslate nohighlight">\(w\)</span> must observe the budget constraints: <span class="math notranslate nohighlight">\(\sum_{v\in V_n} w_{nv} \leq b_n \ \forall n\in N\)</span>. Finallly, we say that vector <span class="math notranslate nohighlight">\(w\)</span> is maximally affordable if we have the equality <span class="math notranslate nohighlight">\(\sum_{v\in V_n\cap S} w_{nv}=b_n\)</span> for each nominator <span class="math notranslate nohighlight">\(n\)</span> that has at least one neighbor in <span class="math notranslate nohighlight">\(S\)</span>.</p>


<h2 id="-2.-algorithm">2. Algorithm<a class="headerlink" href="#-2.-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The following algorithm finds a committee <span class="math notranslate nohighlight">\(S\subseteq V\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>, together with a maximally affordable edge weight vector <span class="math notranslate nohighlight">\(w\)</span> for it. We remark that a better weight vector <span class="math notranslate nohighlight">\(w'\)</span> for <span class="math notranslate nohighlight">\(S\)</span> can be obtained by finding its min-norm max flow vector as a post-computation - see <a class="reference external" href="2. The min-norm max-flow problem.html">our note on the MNMF problem</a>. </p>
<p><strong>Algorithm: Sequential Phragmén Method.</strong></p>
<ol class="simple">
<li><p>Set <span class="math notranslate nohighlight">\(S \leftarrow \emptyset, \ 
l_n \leftarrow 0 \ \forall n\in N, \ 
l_v \leftarrow 0 \ \forall v\in V\)</span>. </p></li>
<li><p>For <span class="math notranslate nohighlight">\(i=1,\cdots,m\)</span>:<ul class="simple">
<li><p>Update <span class="math notranslate nohighlight">\(l_v \leftarrow \frac{1+\sum_{n\in N_v} l_n\cdot b_n}{\sum_{n\in N_v} b_n}\)</span> for each <span class="math notranslate nohighlight">\(v\in V\setminus S\)</span> (<span class="math notranslate nohighlight">\(l_v\)</span> unchanged for <span class="math notranslate nohighlight">\(v\in S\)</span>),</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(v_i\in argmin_{v\in V\setminus S} l_v\)</span> and update <span class="math notranslate nohighlight">\(S\leftarrow S\cup \{v_i\}\)</span>,</p></li>
<li><p>For each <span class="math notranslate nohighlight">\(n\in N_{v_i}\)</span>, store <span class="math notranslate nohighlight">\(w_{nv_i}\leftarrow (l_{v_i} - l_n)b_n\)</span>, and update  <span class="math notranslate nohighlight">\(l_n \leftarrow l_{v_i}\)</span> (<span class="math notranslate nohighlight">\(l_n\)</span> unchanged for <span class="math notranslate nohighlight">\(n\in N\setminus N_{v_i}\)</span>),</p></li>
</ul>
</p></li>
<li><p>For each edge <span class="math notranslate nohighlight">\(nv\in E\)</span> having a non-zero weight, update its weight  <span class="math notranslate nohighlight">\(w_{nv}\leftarrow w_{nv}/l_{n}\)</span>.</p></li>
<li><p>Return <span class="math notranslate nohighlight">\((S,w)\)</span>.</p></li>
</ol>
<p><strong>Running time</strong>: We assume that each candidate validator has at least one supporter. Each one of the <span class="math notranslate nohighlight">\(m\)</span> rounds performs <span class="math notranslate nohighlight">\(O(|E|)\)</span> arithmetic operations, because each relation <span class="math notranslate nohighlight">\(nv\in E\)</span> is inspected at most twice per round. Hence, assuming that floating operations and table lookups take constant time, the running time of the algorithm is <span class="math notranslate nohighlight">\(O(m|E|)\)</span>.</p>
<p><strong>General idea</strong>: The algorithm elects validators sequentially. It executes <span class="math notranslate nohighlight">\(m\)</span> rounds, electing a new validator <span class="math notranslate nohighlight">\(v_i\)</span> in the <span class="math notranslate nohighlight">\(i\)</span>-th round, and adding it to set <span class="math notranslate nohighlight">\(S\)</span>. The algorithm also progressively builds an edge weight vector, defining all weights <span class="math notranslate nohighlight">\(\{w_{nv_i}: \ n\in N_{v_i}\}\)</span> of edges incident to <span class="math notranslate nohighlight">\(v_i\)</span> as soon as <span class="math notranslate nohighlight">\(v_i\)</span> is elected. Finally, in step 3. the weight vector <span class="math notranslate nohighlight">\(w\)</span> is updated to ensure that that it is maximally affordable.</p>
<p>The algorithm keeps track of <em>scores</em> over nominators and validators. For each nominator <span class="math notranslate nohighlight">\(n\in N\)</span>, <span class="math notranslate nohighlight">\(n\)</span>’s score is the fraction of its budget <span class="math notranslate nohighlight">\(b_n\)</span> that has been used up so far; i.e., <span class="math notranslate nohighlight">\(l_n:=\frac{1}{b_n}\sum_{v\in V_n} w_{nv}\)</span>. The guiding principle of this heuristic is to <em>try to minimize the maximum score <span class="math notranslate nohighlight">\(l_n\)</span> over all nominators in each round</em>. Consider round <span class="math notranslate nohighlight">\(i\)</span>: if a new validator <span class="math notranslate nohighlight">\(v_i\)</span> is elected, we assign one unit of support to it, i.e. we define edge weights so that <span class="math notranslate nohighlight">\(\sum_{n\in N_{v_i} }w_{nv_i}=1\)</span> (this choice of constant is irrevelant, and will change when vector <span class="math notranslate nohighlight">\(w\)</span> is updated in step 3.). These edge weights are chosen so that all supporters of <span class="math notranslate nohighlight">\(v_i\)</span> end up with the same score at the end of round <span class="math notranslate nohighlight">\(i\)</span>, i.e. for all <span class="math notranslate nohighlight">\(n'\in N_{v_i}\)</span>:
\begin{align}
l_{n’}^{new} 
&amp;= \frac{\sum_{n\in N_{v_i}} l_n^{new}\cdot b_n}{\sum_{n\in N_{v_i}}  b_n} 92
&amp; = \frac{\sum_{n\in N_{v_i}} (l_n^{old}\cdot b_n +w_{nv_i})}{\sum_{n\in N_{v_i}}  b_n} 92
&amp; = \frac{1+ \sum_{n\in N_{v_i}} l_n^{old}\cdot b_n}{\sum_{n\in N_{v_i}}  b_n} =: l_{v_i}.92
\end{align}</p>
<p>This common nominator score is precisely our definition of validator <span class="math notranslate nohighlight">\(v_i\)</span>’s score <span class="math notranslate nohighlight">\(l_{v_i}\)</span>, and the algorithm greedily chooses the validator with smallest score in each round (breaking ties arbitrarily). </p>
<p><strong>Proof of correctness</strong>: It remains to show that the chosen edge weights are always non-negative, and that <span class="math notranslate nohighlight">\(w\)</span> is maximally affordable after step 3. For this, we need the following lemma, which states that scores never decrease. Let <span class="math notranslate nohighlight">\(l_n^{(i)}\)</span> and <span class="math notranslate nohighlight">\(l_v^{(i)}\)</span> represent respectively that scores of nominator <span class="math notranslate nohighlight">\(n\)</span> and validator <span class="math notranslate nohighlight">\(v\)</span> at the end of the <span class="math notranslate nohighlight">\(i\)</span>-th round. </p>
<p><strong>Lemma 1</strong>: <span class="math notranslate nohighlight">\(l_v^{(i)}\leq l_v^{(i+1)}\)</span> and <span class="math notranslate nohighlight">\(l_n^{(i)}\leq l_n^{(i+1)}\)</span> for each <span class="math notranslate nohighlight">\(n\in N\)</span>, <span class="math notranslate nohighlight">\(v\in S\)</span> and <span class="math notranslate nohighlight">\(i&lt;m\)</span>.</p>
<p><em>Proof</em>. We prove the inequalities by strong induction on <span class="math notranslate nohighlight">\(i\)</span>, where the base case <span class="math notranslate nohighlight">\(i=0\)</span> is trivial if we set <span class="math notranslate nohighlight">\(l_v^{(0)}=l_n^{(0)}:=0\)</span> for each <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(v\)</span>. Assume now that all the proposed inequalities hold up to <span class="math notranslate nohighlight">\(i-1\)</span>.</p>
<p>Validator inequalities: Consider a validator <span class="math notranslate nohighlight">\(v_j\in S\)</span>. If <span class="math notranslate nohighlight">\(j\leq i\)</span>, then the identity <span class="math notranslate nohighlight">\(l_{v_j}^{(i+1)}=l_{v_j}^i\)</span> follows from the fact that a validator’s score doesn’t change anymore once it has been elected. Else, if <span class="math notranslate nohighlight">\(j&gt;i\)</span>, </p>
<div class="math notranslate nohighlight">
\[l_{v_j}^{(i+1)}:=\frac{1+\sum_{n\in N_{v_j} } b_n\cdot l_n^{(i)}}{\sum_{n\in N_{v_j} } b_n} 
\geq \frac{1+\sum_{n\in N_{v_j} } b_n\cdot l_n^{(i-1)}}{\sum_{n\in N_{v_j} } b_n} =: l_{v_j}^{(i)},\]</div>
<p>where we used the nominator inequalities <span class="math notranslate nohighlight">\(l_n^{(i-1)}\leq l_n^{(i)}\)</span> assumed by induction hypothesis. This shows the validator inequalities up to <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>Nominator inequalities: Consider now a nominator <span class="math notranslate nohighlight">\(n\)</span>, and assume by contradiction that <span class="math notranslate nohighlight">\(l_n^{(i+1)}&lt;l_n^{(i)}\)</span>. As <span class="math notranslate nohighlight">\(n\)</span>’s score has changed in round <span class="math notranslate nohighlight">\(i+1\)</span>, <span class="math notranslate nohighlight">\(n\)</span> must support validator <span class="math notranslate nohighlight">\(v_{i+1}\)</span>, and so <span class="math notranslate nohighlight">\(l_n^{(i+1)}=l_{v_{i+1}}^{(i+1)}\)</span>. On the other hand, <span class="math notranslate nohighlight">\(l_n^{(i)}=l_n^{(j)} = l_{v_{j}}^{(j)}\)</span> for some <span class="math notranslate nohighlight">\(j\leq i\)</span>. Putting things together,</p>
<div class="math notranslate nohighlight">
\[l_{v_j}^{(j)} = l_n^{(i)} &gt; l_n^{(i+1)} = l_{v_{i+1}}^{(i+1)} \geq l_{v_{i+1}}^{(j)}, \]</div>
<p>where the last inequality follows from validator inequalities up to <span class="math notranslate nohighlight">\(i\)</span>, which we just proved in the previous paragraph. We conclude that in round <span class="math notranslate nohighlight">\(j\)</span>, validator <span class="math notranslate nohighlight">\(v_{i+1}\)</span> had a strictly smaller score than <span class="math notranslate nohighlight">\(v_j\)</span>, which contradicts the choice of <span class="math notranslate nohighlight">\(v_j\)</span>.
<span class="math notranslate nohighlight">\(\square\)</span></p>
<p>It easily follows that all edge weights are non-negative. Moreover, using the definition of the nominator scores, before step 3. we have the equalities <span class="math notranslate nohighlight">\(l_n\cdot b_n=\sum_{v\in S\cap V_n}w_{nv}\)</span> for each nominator <span class="math notranslate nohighlight">\(n\)</span> with at least one neighbor in <span class="math notranslate nohighlight">\(S\)</span>, so after step 3. we have <span class="math notranslate nohighlight">\(b_n=\sum_{v\in S\cap V_n}w_{nv}\)</span>.</p>


<h2 id="-3.-axiomatic-properties">3. Axiomatic properties<a class="headerlink" href="#-3.-axiomatic-properties" title="Permalink to this headline">¶</a></h2>
<p>In the research literature of approval-based miltiwinner elections, it is common to take an axiomatic approach and define properties of voting methods that are intuitively desirable (see our main reference <a class="reference external" href="https://aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14757/13791">Brill et al. (2017)</a>, as well as <a class="reference external" href="https://arxiv.org/abs/1609.05370">Sánchez-Fernández et al. (2018)</a>). These properties apply to the elected committee only, ignoring the edge weights.</p>
<p>For example, a voting method is called <em>house monotonic</em> if, for any instance, the elected candidates are all still elected if the number <span class="math notranslate nohighlight">\(m\)</span> of winners is increased. As our algorithm elects validators iteratively, it is trivially house monotonic.</p>
<p>We focus on the property of <em>proportional justified representation</em> (PJR), which establishes that if a group of nominators has sufficient budget, and their preferences are sufficiently aligned, then they must be well represented in the elected committee. More formally, a voting method satifies PJR if for any instance <span class="math notranslate nohighlight">\((N\cup V, E, b, m)\)</span> electing a committee <span class="math notranslate nohighlight">\(S\)</span>, and any integer <span class="math notranslate nohighlight">\(1\leq t\leq m\)</span>, there is no nominator subset <span class="math notranslate nohighlight">\(N'\subseteq N\)</span> such that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sum_{n \in N'} b_n \geq \frac{t}{m} \cdot \sum_{n \in N} b_n\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(|\cap_{n\in N'} V_n| \geq t\)</span>, and</p></li>
<li><p><span class="math notranslate nohighlight">\(|S\cap (\cup_{n\in N'} V_n)| &lt; t\)</span>.</p></li>
</ul>
<p>Brill et al (2017) proved that the proposed algorithm, sequential Phragmén, satifies PJR,  making it the first known polynomial-time method with this property. We present a proof next.</p>
<p><strong>Lemma 2:</strong> Sequential Phragmén satisfies PJR.</p>
<p><em>Proof:</em> Assume the opposite, hence there is an instance <span class="math notranslate nohighlight">\((N\cup V, E, b, m)\)</span> with output committe <span class="math notranslate nohighlight">\(S\)</span>, an integer <span class="math notranslate nohighlight">\(1\leq t\leq m\)</span> and a nominator subset <span class="math notranslate nohighlight">\(N'\subseteq N\)</span> as in the definition above.</p>
<p>For simplicity, we ignore the update of the weight vector performed in step 3. of the algorithm. Hence, every elected validator in <span class="math notranslate nohighlight">\(S\)</span> receives a support of one unit, and the sum of supports over <span class="math notranslate nohighlight">\(S\)</span> is <span class="math notranslate nohighlight">\(m\)</span>. Since we know that each budget constraint is violated by a multiplicative term of at most <span class="math notranslate nohighlight">\(l_{v_m}\)</span> (the score of the last added validator), we obtain the bound

\begin{equation}
l_{v_m}\geq \frac{m}{\sum_{n\in N} b_n}.
\end{equation}
As <span class="math notranslate nohighlight">\(l_{v_m}\)</span> is an upper bound on the nominator score <span class="math notranslate nohighlight">\(l_n\)</span> for each <span class="math notranslate nohighlight">\(n\in N\)</span> (by Lemma 1), and <span class="math notranslate nohighlight">\(l_n\)</span> is the proportion of <span class="math notranslate nohighlight">\(n\)</span>’s budget that’s used, the previous inequality is tight only if <span class="math notranslate nohighlight">\(l_n = m/\sum_{n\in N} b_n\)</span> for each <span class="math notranslate nohighlight">\(n\in N\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(S'=S\cap(\cup_{n\in N'} V_n)\)</span>, where <span class="math notranslate nohighlight">\(|S'|\leq t-1\)</span> by hypothesis. Since nominators in <span class="math notranslate nohighlight">\(N'\)</span> only need to provide support to validators in <span class="math notranslate nohighlight">\(S'\)</span>, the sum over <span class="math notranslate nohighlight">\(N'\)</span> of used budgets must be smaller than <span class="math notranslate nohighlight">\(|S'|\)</span>, i.e. 
<span class="math notranslate nohighlight">\(\sum_{n\in N'} l_n\cdot b_n \leq |S'| \leq t-1.\)</span>
By a (weighted) average argument, this implies that there is a nominator <span class="math notranslate nohighlight">\(n'\in N'\)</span> with score 
<span class="math notranslate nohighlight">\(l_{n'}\leq \frac{\sum_{n\in N'} l_n\cdot b_n}{\sum_{n\in N'} b_n} &lt; \frac{t}{\sum_{n\in N'} b_n} \leq \frac{t}{\frac{t}{m} \sum_{n\in N} b_n} = \frac{m}{ \sum_{n\in N} b_n},\)</span>
where the last inequality is by hypothesis. This implies that the inequality <span class="math notranslate nohighlight">\(l_{v_m} &gt; m/\sum_{n\in N} b_n\)</span> is not tight.</p>
<p>Consider now running a new round (round <span class="math notranslate nohighlight">\(m+1\)</span>) on the algorithm, and fix an unelected validator <span class="math notranslate nohighlight">\(v'\in \cap_{n\in N'} V_n\)</span> (which must exist by hypothesis). If we compute the score of <span class="math notranslate nohighlight">\(v'\)</span> in this round, we get 
<span class="math notranslate nohighlight">\(l_{v'} = \frac{1+\sum_{n\in N_{v'} } l_n\cdot b_n}{\sum_{n\in N_{v'}} b_n}\leq 
\frac{1+\sum_{n\in N'} l_n\cdot b_n}{\sum_{n\in N'} b_n},\)</span>
where we used the fact that <span class="math notranslate nohighlight">\(N'\subseteq N_{v'}\)</span>, and that reducing the set of nominators over which the unit support for <span class="math notranslate nohighlight">\(v'\)</span> is split can only increase the nominator scores. Using the known upper bound on the nominator, and the known lower bound on the denominator, we obtain 
<span class="math notranslate nohighlight">\(l_{v'}\leq \frac{1+\sum_{n\in N'} l_n\cdot b_n}{\sum_{n\in N'} b_n}
\leq \frac{1 + (t-1)}{\frac{t}{m} \sum_{n\in N} b_n} = \frac{m}{\sum_{n\in N} b_n} &lt; l_{v_m}.\)</span>
This implies that <span class="math notranslate nohighlight">\(l_{v_m} &gt; l_{v'} \geq l_{v_{m+1}}\)</span>, which contradicts Lemma 1.
<span class="math notranslate nohighlight">\(\square\)</span></p>




          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
            <a href="3. The maximin support problem.html" title="Material"
               class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               rel="prev">
              <div class="md-flex__cell md-flex__cell--shrink">
                <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
              </div>
              <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
                <span class="md-flex__ellipsis">
                  <span
                      class="md-footer-nav__direction"> Previous </span> 3. The maximin support problem </span>
              </div>
            </a>
          
          
            <a href="5. A Phragmén-like Heuristic.html" title="Admonition"
               class="md-flex md-footer-nav__link md-footer-nav__link--next"
               rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span
                class="md-flex__ellipsis"> <span
                class="md-footer-nav__direction"> Next </span> 5. A Phragmén-like Heuristic </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink"><i
                class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
            Created using
            <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
        <div class="md-footer-social">
          <link rel="stylesheet" href="../../_static/fonts/font-awesome.css">
            <a href="https://github.com/w3f/research" class="md-footer-social__link fa fa-github"></a>
            <a href="https://twitter.com/web3foundation" class="md-footer-social__link fa fa-twitter"></a>
            <a href="https://medium.com/web3foundation" class="md-footer-social__link fa fa-medium"></a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>