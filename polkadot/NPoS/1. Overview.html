
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>1. Overview of results for the NPoS election problem &#8212; Web3 Foundation Research  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/stylesheets/extra.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"], "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]], "processEscapes": true}, "HTML-CSS": {"fonts": ["TeX"]}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2. The min-norm max-flow problem" href="2. The min-norm max-flow problem.html" />
    <link rel="prev" title="Intro to Nominated Proof-of-Stake" href="index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="-1.-overview-of-results-for-the-npos-election-problem">
<h1>1. Overview of results for the NPoS election problem<a class="headerlink" href="#-1.-overview-of-results-for-the-npos-election-problem" title="Permalink to this headline">¶</a></h1>
<p>In this note we give a technical presentation of the problem of electing validators for nominated proof-of-stake, and an overview of our results.</p>
<p>Assume we need to select <span class="math notranslate nohighlight">\(m\)</span> validators. We will run a vote-weighted, approval-based committee election to select them. This means that each nominator can submit a list containing any number of trusted candidates without an order of preference, and that the nominator’s vote is weighted by the amount of stake it puts down.</p>
<p>Informally speaking the objectives of the election are to capture as much of the nominators’ stake as possible, and to partition this stake pool into <span class="math notranslate nohighlight">\(m\)</span> pieces of roughly equal weight, with one elected validator representing each piece. We want an equal distribution of stake over the validators because in some of our protocols all validators are given the same voting power, so we want to make it difficult for an adversary to control even a few validators. However, we allow for a nominator’s stake to be fractionally split into supporting several of its trusted validators being elected. Another of our objectives will be fair proportionality, in the sense that if a group of nominators controls a fraction <span class="math notranslate nohighlight">\(p\)</span> of the total stake then they should be represented by <span class="math notranslate nohighlight">\(\approx p\cdot m\)</span> validators. We establish these objectives more formally in the Objectives section.</p>
<div class="section" id="problem-statement-and-notation">
<h2>Problem statement and notation<a class="headerlink" href="#problem-statement-and-notation" title="Permalink to this headline">¶</a></h2>
<p><strong>Note 1:</strong> In order to simplify the underlying optimization problem, at genesis we will not allow nominators and validator candidates to indicate the interest rate they wish to earn over their stake. This feature might be added in the future, but it is not considered in this note, and we assume that the payoffs will be decided by governance.</p>
<p><strong>Note 2:</strong> For simplicity, in our model we assume without loss of generality that validator candidates have no stake of their own, by performing the following reduction. Any staked candidate is considered as two parties: a nominator and a non-staked validator candidate, with the former backing the latter exclusively.</p>
<p>As the NPoS problem is a committee election problem, we use some notation coming from election theory. The input can be succintly represented by a bipartite graph <span class="math notranslate nohighlight">\((N\cup V, E)\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the set of nominators, <span class="math notranslate nohighlight">\(V\)</span> is the set of validator candidates, and <span class="math notranslate nohighlight">\(E\subseteq N\times V\)</span> is the set of edges containing the pair <span class="math notranslate nohighlight">\(nv\)</span> whenever nominator <span class="math notranslate nohighlight">\(n\)</span> included <span class="math notranslate nohighlight">\(v\)</span> in its list of trusted candidates. We are also given a vector <span class="math notranslate nohighlight">\(b\in\mathbb{R}_{\geq 0}^N\)</span> of “budgets”, where each component <span class="math notranslate nohighlight">\(b_n\)</span> represents the budget or stake of nominator <span class="math notranslate nohighlight">\(n\)</span>. Finally, we are given the target number <span class="math notranslate nohighlight">\(m\)</span> of validators to elect.</p>
<p>The output will be a committee <span class="math notranslate nohighlight">\(S\subseteq V\)</span> of <span class="math notranslate nohighlight">\(m\)</span> validators, together with a list of edge weights represented by a vector <span class="math notranslate nohighlight">\(w\in\mathbb{R}^E_{\geq 0}\)</span>, where a component <span class="math notranslate nohighlight">\(w_{nv}\)</span> indicates the amount of <span class="math notranslate nohighlight">\(n\)</span>’s budget  assigned to support <span class="math notranslate nohighlight">\(v\)</span>. We require vector <span class="math notranslate nohighlight">\(w\)</span> to have non-negative components and  to be “affordable”, i.e. to observe the budget constraints <span class="math notranslate nohighlight">\(\sum_{v\in V: \ nv\in E} w_{nv} \leq b_n\)</span> for each nominator <span class="math notranslate nohighlight">\(n\in N\)</span>. Finally, we prefer solutions <span class="math notranslate nohighlight">\((S,w)\)</span> that are “maximally affordable”, meaning that <span class="math notranslate nohighlight">\(\sum_{v\in S: \ nv\in E} w_{nv} = b_n\)</span> for each nominator <span class="math notranslate nohighlight">\(n\)</span> that has at least one neighbor in <span class="math notranslate nohighlight">\(S\)</span>, i.e. all of the available budget is used.</p>
</div>
<div class="section" id="operational-concerns">
<h2>Operational concerns<a class="headerlink" href="#operational-concerns" title="Permalink to this headline">¶</a></h2>
<p>Before formally defining the objectives we consider to elect a committee, we have a look at the operational side of the problem.</p>
<div class="section" id="efficient-algorithms">
<h3>Efficient algorithms<a class="headerlink" href="#efficient-algorithms" title="Permalink to this headline">¶</a></h3>
<p>We call an algorithm “efficient” if its running time is polynomial in the size of the input, and “highly efficient” if its running time is linear in the size of the input. It is important for all on-chain algorithms to be highly efficient, because they must scale well as the size of the Polkadot network grows. In contrast, off-chain algorithms are only required to be efficient.</p>
<p>In our election problem, the input is given by the tuple <span class="math notranslate nohighlight">\((N\cup V, E, b, m)\)</span>, and its size is <span class="math notranslate nohighlight">\(O(|E|\cdot \log(|V|)+|N|\cdot B)\)</span>, where the first term is the size of the preference lists and the second term is the size of the nominator budget list, and <span class="math notranslate nohighlight">\(B\)</span> is an upper bound on the bit-length of each budget. We assume henceforth that <span class="math notranslate nohighlight">\(B\)</span> is constant, hence the size of the input is <span class="math notranslate nohighlight">\(O(|E|\cdot\log(|V|))\)</span>. </p>
<p>However, to give ourselves more leeway, we relax the above definition and allow for highly efficient algorithms to have an additional linear dependence on the committee size <span class="math notranslate nohighlight">\(m\)</span>. This is justified by the fact that, unlike the other variables, the value of <span class="math notranslate nohighlight">\(m\)</span> does not grow linearly with the number of nodes on the Polkadot network, but only grows with the number of parachains. Therefore, assuming that <span class="math notranslate nohighlight">\(\log |V| \leq m\)</span>, we define an algorithm to be <em>highly efficient</em> if its running time is</p>
<div class="math notranslate nohighlight">
\[O(|E|\cdot (m+ \log(|V|))=O(|E|\cdot m).\]</div>
</div>
<div class="section" id="who-elects-the-committee-">
<h3>Who elects the committee?<a class="headerlink" href="#who-elects-the-committee-" title="Permalink to this headline">¶</a></h3>
<p>Given an input <span class="math notranslate nohighlight">\((N\cup V, E, b, m)\)</span> to the election problem, anyone is welcome to submit a tentative solution <span class="math notranslate nohighlight">\((S,w)\)</span>. In particular, we expect validator candidates to submit tentative solutions in which they themselves are part of the elected committee. Among the submitted solutions, the best one is selected publicly.</p>
<p>Therefore, we actually need two types of algorithms: a <em>committee-finding</em> algorithm, which will be run off-chain by each candidate and returns a reasonably good solution, and a <em>committee-comparing</em> algorithm, which will be run on-chain and chooses between these submissions.</p>
</div>
<div class="section" id="committee-finding-algorithm--off-chain-">
<h3>Committee-finding algorithm (off-chain)<a class="headerlink" href="#committee-finding-algorithm--off-chain-" title="Permalink to this headline">¶</a></h3>
<p>Each party submitting a tentative solution is welcome to use their favorite committee-finding algorithm. In any case, we propose to them two or three algorithms, which provide a trade-off between efficiency and quality. At least one of these algorithms should be highly efficient, so that it can be run on-chain in the edge case that no-one proposes good tentative committees.  The other algorithms will be slower but their output committee will likely be better, so they will be prefered by parties with more computational power. </p>
</div>
<div class="section" id="committee-comparing-algorithm--on-chain-">
<h3>Committee-comparing algorithm (on-chain)<a class="headerlink" href="#committee-comparing-algorithm--on-chain-" title="Permalink to this headline">¶</a></h3>
<p>We need to establish a ranking over the collection of all possible committees. The rules for this ranking should be simple to state, unambiguous and public. Moreover, we need a highly efficient committee-comparing algorithm, which takes two or more solutions as input and outputs the better one according to the established ranking. </p>
</div>
</div>
<div class="section" id="objectives">
<h2>Objectives<a class="headerlink" href="#objectives" title="Permalink to this headline">¶</a></h2>
<p>We have identified three main objectives of the committee election. These are:</p>
<ul class="simple">
<li><p><em>Balance:</em> Once a committee is elected, distribute the nominators’ stake as evenly as possible over the elected validators.</p></li>
<li><p><em>Support:</em> Choose a committee that allows each validator to receivs as much stake support from the nominators as possible.</p></li>
<li><p><em>Fair representation:</em> Choose a committee where nominators are not under-represented proportional to their budgets.</p></li>
</ul>
<p>We go over each of these objectives in detail.</p>
<div class="section" id="balance">
<h3>Balance<a class="headerlink" href="#balance" title="Permalink to this headline">¶</a></h3>
<p>Given an input <span class="math notranslate nohighlight">\((N\cup S, E, b, m)\)</span> of the election problem, we are looking for a solution given by a pair <span class="math notranslate nohighlight">\((S,w)\)</span>, where <span class="math notranslate nohighlight">\(S\subseteq V\)</span> is a committee of size <span class="math notranslate nohighlight">\(m\)</span>, and <span class="math notranslate nohighlight">\(w\in\mathbb{R}^E_{\geq 0}\)</span> is a vector of edge weights which is maximally affordable. Relative to vector <span class="math notranslate nohighlight">\(w\)</span>, each validator <span class="math notranslate nohighlight">\(v\in S\)</span> receives a “support” of <span class="math notranslate nohighlight">\(supp_w(v):=\sum_{n\in N: \ nv\in E} w_{nv}\)</span>. In order to achieve a balanced solution, we want to make the list of supports <span class="math notranslate nohighlight">\(\{supp_w(v)\}_{v\in S}\)</span> as uniformly distributed as possible.</p>
<p>For a given committee <span class="math notranslate nohighlight">\(S\subseteq V\)</span>, the <em>min-norm max-flow</em> problem (MNMF) consists of finding a maximally affordable vector <span class="math notranslate nohighlight">\(w\)</span> for <span class="math notranslate nohighlight">\(S\)</span> that minimizes the sum of squared supports <span class="math notranslate nohighlight">\(\sum_{v\in S} (supp_w(v))^2\)</span>. </p>
<p>In <a class="reference external" href="2. The min-norm max-flow problem.html">our note on the MNMF problem</a>, we explain in detail why the vector <span class="math notranslate nohighlight">\(w\)</span> thus obtained is optimal for <span class="math notranslate nohighlight">\(S\)</span> for the purposes of NPoS. We also provide two algorithms to solve MNMF, with running times respectively of <span class="math notranslate nohighlight">\(O(|E|m+m^3)\)</span> and <span class="math notranslate nohighlight">\(O(|E|m^2\log m)\)</span>, where the latter one, called star balancing, is much easier to implement and usually as fast as the former. </p>
<p>Let <span class="math notranslate nohighlight">\(F\)</span> be the complexity of solving an instance of MNMF, which is dependent on the algorithm used, but we consider it to be highly efficient (through a slight stretch of the definition). This complexity will be referenced in many of our algorithms.</p>
<p>We say that a solution <span class="math notranslate nohighlight">\((S,w)\)</span> observes the balance property if <span class="math notranslate nohighlight">\(w\)</span> is a solution to the MNMF problem for <span class="math notranslate nohighlight">\(S\)</span>. We will ensure that all of our proposed election algorithms have the balance property by running an MNMF algorithm as a post-computation if needed. We also remark that the balance property can be checked on a solution in only <span class="math notranslate nohighlight">\(O(|E|)\)</span> time.</p>
</div>
<div class="section" id="support">
<h3>Support<a class="headerlink" href="#support" title="Permalink to this headline">¶</a></h3>
<p>For a feasible solution <span class="math notranslate nohighlight">\((S,w)\)</span>, we extend the notion of support and say that committee <span class="math notranslate nohighlight">\(S\)</span> receives a support from <span class="math notranslate nohighlight">\(w\)</span> of </p>
<div class="math notranslate nohighlight">
\[supp_w(S):=\min_{v\in S} supp_w (v)= \min_{v\in S} \sum_{n\in N: \ nv\in E} w_{nv}.\]</div>
<p>In the <em>maximin support problem</em>, the objective is to find a feasible solution <span class="math notranslate nohighlight">\((S,w)\)</span> to the given NPoS instance of maximum support <span class="math notranslate nohighlight">\(supp_w(S)\)</span>.</p>
<p>Unfortunately, this optimization problem is NP-hard, so we must resort to heuristics. In particular, we are interested in heuristics with a guarantee that their output solution <span class="math notranslate nohighlight">\((S,w)\)</span> has a support value <span class="math notranslate nohighlight">\(supp_w(S)\)</span> that is only a constant mutiplicative factor smaller than the maximum support over all feasible solutions; the closer this factor is to 1, the better. Thus what we want are constant-factor approximation algorithms. </p>
<p>In <a class="reference external" href="3. The maximin support problem.html">our note on the maximin support problem</a>, we motivate the choice of this objective in the context of the NPoS problem. We also provide a 2-factor approximation algorithm that runs in time </p>
<div class="math notranslate nohighlight">
\[\tilde{O}(F\cdot |V|),\]</div>
<p>where the symbol <span class="math notranslate nohighlight">\(\tilde{O}\)</span> means that we are ignoring a multiplicative factor that is logarithmic in <span class="math notranslate nohighlight">\(m\)</span>, and where we recall that <span class="math notranslate nohighlight">\(F\)</span> is the time it takes to solve an MNMF instance. Its output always has the balance property.</p>
</div>
<div class="section" id="fair-representation">
<h3>Fair representation<a class="headerlink" href="#fair-representation" title="Permalink to this headline">¶</a></h3>
<p>In the research literature of approval-based multi-winner elections, it is common to take an axiomatic approach and define properties of voting methods that are intuitively desirable (see <a class="reference external" href="https://aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14757/13791">Brill et al. (2017)</a> as well as <a class="reference external" href="https://arxiv.org/abs/1609.05370">Sánchez-Fernández et al. (2018)</a>). These properties measure the quality of the elected committee only, ignoring the weight distribution.</p>
<p>To measure fair representation, we focus on the property of <em>proportional justified representation</em> (PJR), which establishes that if a group of nominators has sufficient budget, and their lists of trusted candidates are sufficiently aligned, then they must be well represented in the elected committee. Let <span class="math notranslate nohighlight">\(V_n\subseteq V\)</span> represent the set of trusted candidates of a nominator <span class="math notranslate nohighlight">\(n\)</span>. Formally, a committee <span class="math notranslate nohighlight">\(S\)</span> of size <span class="math notranslate nohighlight">\(m\)</span> satifies the PJR property if for any integer <span class="math notranslate nohighlight">\(1\leq t\leq m\)</span>, there is no nominator subset <span class="math notranslate nohighlight">\(N'\subseteq N\)</span> such that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sum_{n \in N'} b_n \geq \frac{t}{m} \cdot \sum_{n \in N} b_n\)</span>, </p></li>
<li><p><span class="math notranslate nohighlight">\(|\cap_{n\in N'} V_n| \geq t\)</span>, and </p></li>
<li><p><span class="math notranslate nohighlight">\(|S\cap (\cup_{n\in N'} V_n)| &lt; t\)</span>.</p></li>
</ul>
<p>In other words, if a subset <span class="math notranslate nohighlight">\(N'\)</span> of the nominators has a fraction <span class="math notranslate nohighlight">\(t/m\)</span> of the overall budget and at least <span class="math notranslate nohighlight">\(t\)</span> trusted candidates in common, then there are at least <span class="math notranslate nohighlight">\(t\)</span> validators in the committee that are trusted by someone in <span class="math notranslate nohighlight">\(N'\)</span>. A committee-electing algorithm satisfies the PJR property if its output committee always satisfies PJR for any input instance.</p>
<p>The definition of the PJR property was inspired by a method proposed by the end of the 19th century by Swedish mathematician Edvard Phragmén. His method satisifes PJR, but is not computationally efficient. <a class="reference external" href="https://aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14757/13791">Brill et al. (2017)</a> gave the first known polynomial-time method with this property, called sequential Phragmén’s method.</p>
<p>In <a class="reference external" href="4. Sequential Phragmén’s method.html">our note on the sequential Phragmén’s method</a>, we adapt this algorithm to our NPoS problem, and provide a proof that it observes the PJR property. In particular, the algorithm runs in time <span class="math notranslate nohighlight">\(O(|E|\cdot m)\)</span>, hence it is highly efficient. If we assume that we run an MNMF algorithm as a post-computation to achieve the balance property, then the algorithm runs in time <span class="math notranslate nohighlight">\(O(F)\)</span>. However we remark that it does not provide a constant-factor guarantee for the maximin support objective.</p>
<p>To finalize this section, we remark that the PJR property ensures that no subset of the nominators is under-represented proportional to their budgets. On the other hand, in <a class="reference external" href="3. The maximin support problem.html">our note on the maximin support problem</a> we provide some evidence that using the maximin support objective ensures that no subset of the nominators is over-represented. </p>
</div>
</div>
<div class="section" id="overview-of-our-results">
<h2>Overview of our results<a class="headerlink" href="#overview-of-our-results" title="Permalink to this headline">¶</a></h2>
<p>A careful read of the previous section reveals that we are so-far lacking an algorithm that simultaneously satisfies the PJR property of fair representation and provides a constant-factor approximation guarantee for the maximin support objective. In <a class="reference external" href="5. A Phragmén-like Heuristic.html">this note</a> we propose a new heuristic that solves this problem as follows: it takes as input an NPoS instance <span class="math notranslate nohighlight">\((N\cup V, E, b, m)\)</span> and a feasible solution <span class="math notranslate nohighlight">\((S,w)\)</span>, and returns a new feasible solution <span class="math notranslate nohighlight">\((S',w')\)</span> such that 
a) <span class="math notranslate nohighlight">\(S'\)</span> satisfies the PJR property, and
b) <span class="math notranslate nohighlight">\(supp_{w'}(S')\geq supp_w(S)\)</span>.</p>
<p>It is thus a “PJR-enabler”: if it is composed with a constant-factor approximation algorithm for the maximin support objective, then the resulting composition of algorithms simultaneously satisifies the PJR property and provides the same constant-factor approximation. Its running time is <span class="math notranslate nohighlight">\(\tilde{O}(|E|\cdot m)\)</span>, hence it is highly efficient (recall that <span class="math notranslate nohighlight">\(\tilde{O}\)</span> means we ignore a factor logarithmic in <span class="math notranslate nohighlight">\(m\)</span>).</p>
<p>Checking whether a committee <span class="math notranslate nohighlight">\(S\)</span> satisfies PJR is NP-hard. However, in <a class="reference external" href="5. A Phragmén-like Heuristic.html">our note on the new heuristic</a> we define a stronger version of the proportional justified representation property, which we here call PJR’ for short, that implies PJR and that can be inspected in polynomial time. We also present a “PJR’-checker”, i.e. an algorithm that checks if a given committee satisfies PJR’, in time <span class="math notranslate nohighlight">\(O(|E|)\)</span>. In fact, our PJR-enabler is also a PJR’-enabler, and thus all of our proposed algorithms satisfy the PJR’ property.</p>
<p>Finally, our new heuristic also gives rise to a <span class="math notranslate nohighlight">\(3.15\)</span>-approximation algorithm that satisifes PJR’, in time <span class="math notranslate nohighlight">\(\tilde{O}(F\cdot m)\)</span>.</p>
<div class="section" id="committee-finding">
<h3>Committee finding<a class="headerlink" href="#committee-finding" title="Permalink to this headline">¶</a></h3>
<p>We can thus propose the following committee-finding algorithms. All of them satisfy the balance property and the PJR’ fair representaion property.</p>
<ul class="simple">
<li><p>A <a class="reference external" href="3. The maximin support problem.html"><span class="math notranslate nohighlight">\(2\)</span>-factor approximation algorithm</a> (together with our PJR’-enabler as a post-computation), running in time <span class="math notranslate nohighlight">\(\tilde{O}(F\cdot |V|)\)</span>.</p></li>
<li><p>A <a class="reference external" href="5. A Phragmén-like Heuristic.html"><span class="math notranslate nohighlight">\(3.15\)</span>-factor approximation algorithm</a>, running in time <span class="math notranslate nohighlight">\(\tilde{O}(F\cdot m)\)</span>, and </p></li>
<li><p><a class="reference external" href="4. Sequential Phragmén’s method.html">The sequential Phragmén’s method</a> which provides no constant-factor approximation, and runs in time <span class="math notranslate nohighlight">\(O(F)\)</span>. </p></li>
</ul>
<p>The last algorithm is highly efficient and can be run on-chain in the edge case that no-one proposes good tentative committees. The first two algorithms are given as suggestions to be run off-chain by validators. Numerical experiments give evidence that the slower algorithms also tend to give higher-quality results.</p>
</div>
<div class="section" id="committee-comparing">
<h3>Committee-comparing<a class="headerlink" href="#committee-comparing" title="Permalink to this headline">¶</a></h3>
<p>Notice that both the PJR’ property and the balance property can be ensured by running highly efficient post-computations in conjunction with any heuristic for the maximin support objective. Hence, we will only accept tentative solutions that satisfy both of these properties. Given two or more solutions <span class="math notranslate nohighlight">\((S,w)\)</span> with these properties, we rank them with the following lexicographic preferences (meaning that an objective is checked only if the solutions tie in all previous objectives):</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(k=1,2,\cdots, m\)</span>:<ul>
<li><p><span class="math notranslate nohighlight">\(k\)</span>-th objective: prefer the solution <span class="math notranslate nohighlight">\((S,w)\)</span> that maximizes <span class="math notranslate nohighlight">\(\min_{A\subseteq S, \ |A|=k} \sum_{v\in A} supp_w(v)\)</span>;</p></li>
</ul>
</p></li>
<li><p><span class="math notranslate nohighlight">\((m+1)\)</span>-st objective: prefer the solution <span class="math notranslate nohighlight">\((S,w)\)</span> that minimizes that sum of squared edge weights <span class="math notranslate nohighlight">\(\sum_{nv\in E}w_{nv}^2\)</span>.</p></li>
</ul>
<p>Notice that the very first and most important objective is the maximin support objective, but the following objectives also make sense, as we want to make it progressively harder for an adversary to gain control of a number <span class="math notranslate nohighlight">\(k\)</span> of validators. </p>
<p>The last objective is of little importance, and is mostly used to break any eventual ties avoid having to resort to random selection. The underlying rationale is that it is better to split a nominator’s budget among its trusted elected validators as evenly as possible, to diversify its supports and minimize risk.</p>
<p>We propose an algorithm that takes two or more tentative solutions <span class="math notranslate nohighlight">\((S,w)\)</span>, and outputs one of them following the preferences above. As new tentative solutions arrive over time, we will need to execute several iterations of this algorithm, hence a very high efficency is needed. We consider the output of the previous iteration as the “current favorite solution” in the new iteration, and every other solution is quickly discarded unless it is <em>considerably better</em> than the current favorite in at least one objective. We do this to reward early submissions, and to reduce the number of iterations needed. The algorithm is as follows:</p>
<p>Fix some constants <span class="math notranslate nohighlight">\(\Delta&gt;\delta&gt;0\)</span> (say <span class="math notranslate nohighlight">\(\Delta=0.05\)</span> and <span class="math notranslate nohighlight">\(\delta=0.001\)</span>). Let <span class="math notranslate nohighlight">\(\{(S_i,w_i)\}_{i\in I}\)</span> be the collection of tentative solutions, including the favorite one if there is one. If there is a favorite solution, assume its index is <span class="math notranslate nohighlight">\(0\)</span>, i.e. it is <span class="math notranslate nohighlight">\((S_0, w_0)\)</span>. If at any point in the algorithm only one solution remains, we return it and stop.</p>
<ol class="simple">
<li><p>Discard any solution that is not feasible, does not observe the PJR’ property (using the PJR’-checker), or does not observe the balance property.</p></li>
<li><p>For each <span class="math notranslate nohighlight">\((S_i,w_i)\)</span>, compute and sort its list of supports <span class="math notranslate nohighlight">\(\{supp_{w_i}(v): \ v\in S_i\}=\{d_i^1,d_i^2,\cdots, d_i^m\}\)</span>, so that <span class="math notranslate nohighlight">\(d_i^i\leq d_i^2\leq \cdots \leq d_i^m\)</span>. Then for <span class="math notranslate nohighlight">\(k=1,2,\cdots, m\)</span>:</p>
<ul class="simple">
<li><p>Compute <span class="math notranslate nohighlight">\(max_k:=\max_{i\in I} \sum_{j=1}^k d_i^j\)</span>.</p></li>
<li><p>If there is a favorite solution <span class="math notranslate nohighlight">\((S_0,w_0)\)</span> and <span class="math notranslate nohighlight">\(\sum_{j=1}^k d_0^j\leq (1-\Delta)\cdot max_k\)</span>, discard the favorite solution.</p></li>
<li><p>Discard any non-favorite solution <span class="math notranslate nohighlight">\((S_i,w_i)\)</span> with <span class="math notranslate nohighlight">\(\sum_{j=1}^k d_i^j\leq (1-\delta)\cdot max_k\)</span>.</p></li>
</ul>
</li>
<li><p>Compute <span class="math notranslate nohighlight">\(min_w:= \min_{i\in I} \sum_{nv\in E} w_{nv}^2\)</span>:</p>
<ul class="simple">
<li><p>If there is a favorite solution <span class="math notranslate nohighlight">\((S_0,w_0)\)</span> and <span class="math notranslate nohighlight">\(\sum_{nv\in E} w_{nv}^2 \geq (1+\Delta)\cdot min_w\)</span>, discard the favorite solution.</p></li>
<li><p>Discard any non-favorite solution <span class="math notranslate nohighlight">\((S_i,w_i)\)</span> with <span class="math notranslate nohighlight">\(\sum_{nv\in E}w_{nv}^2\geq (1+\delta)\cdot min_w\)</span>.</p></li>
</ul>
</li>
<li><p>If the favorite solution has not been discarded, return it and stop. Else, among the remaining solutions return the one that was submitted first, breaking eventual ties at random.</p></li>
</ol>
<p>It can be checked that if <span class="math notranslate nohighlight">\(|I|\)</span> tentative solutions are being simultaneously compared, the previous algorithm executes in time <span class="math notranslate nohighlight">\(O(|I|\cdot |E|)\)</span>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Web3 Foundation Research</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../polkadot.html">Polkadot</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html">Polkadot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Availability_and_Validity.html">Availability and Validity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GRANDPA.html">GRANDPA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ICMP.html">ICMP Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Parachain-Allocation.html">Parachain Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Polkadot-Runtime-Environment.html">Polkadot Runtime Environment Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Token Economics.html">Token Economics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BABE.html">BABE</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../NPoS.html">NPoS</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="index.html">Intro to Nominated Proof-of-Stake</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">1. Overview of results for the NPoS election problem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#problem-statement-and-notation">Problem statement and notation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operational-concerns">Operational concerns</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#efficient-algorithms">Efficient algorithms</a></li>
<li class="toctree-l5"><a class="reference internal" href="#who-elects-the-committee-">Who elects the committee?</a></li>
<li class="toctree-l5"><a class="reference internal" href="#committee-finding-algorithm--off-chain-">Committee-finding algorithm (off-chain)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#committee-comparing-algorithm--on-chain-">Committee-comparing algorithm (on-chain)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#objectives">Objectives</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#balance">Balance</a></li>
<li class="toctree-l5"><a class="reference internal" href="#support">Support</a></li>
<li class="toctree-l5"><a class="reference internal" href="#fair-representation">Fair representation</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-our-results">Overview of our results</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#committee-finding">Committee finding</a></li>
<li class="toctree-l5"><a class="reference internal" href="#committee-comparing">Committee-comparing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="2. The min-norm max-flow problem.html">2. The min-norm max-flow problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="3. The maximin support problem.html">3. The maximin support problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="4. Sequential Phragmén’s method.html">4. Sequential Phragmén’s method.</a></li>
<li class="toctree-l3"><a class="reference internal" href="5. A Phragmén-like Heuristic.html">5. A Phragmén-like Heuristic</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../keys.html">Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slashing.html">Slashing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../research_team_members.html">Research Team Members</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../../polkadot.html">Polkadot</a><ul>
  <li><a href="../NPoS.html">NPoS</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Intro to Nominated Proof-of-Stake</a></li>
      <li>Next: <a href="2. The min-norm max-flow problem.html" title="next chapter">2. The min-norm max-flow problem</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Web3 Foundation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../../_sources/polkadot/NPoS/1. Overview.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>