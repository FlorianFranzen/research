
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>BABE &#8212; Web3 Foundation Research  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/stylesheets/extra.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"], "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]], "processEscapes": true}, "HTML-CSS": {"fonts": ["TeX"]}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Sortition" href="sortition.html" />
    <link rel="prev" title="BABE" href="../BABE.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>====================================================================</p>
<p>Author: Handan Kilinc Alper</p>
<p>Last updated: 07.11.2019</p>
<p>Email: handan&#64;web3.foundation</p>
<p>====================================================================
<span class="math notranslate nohighlight">\(
   \def\skvrf{\mathsf{sk}^v}
   \def\pkvrf{\mathsf{pk}^v}
   \def\sksgn{\mathsf{sk}^s}
   \def\pksgn{\mathsf{pk}^s}
   \def\skac{\mathsf{sk}^a}
   \def\pkac{\mathsf{pk}^a} 
   \def\D{\Delta}
   \def\A{\mathcal{A}}
   \def\vrf{\mathsf{VRF}}
   \def\sgn{\mathsf{Sign}}
\)</span></p>
<div class="section" id="babe">
<h1>BABE<a class="headerlink" href="#babe" title="Permalink to this headline">¶</a></h1>
<div class="section" id="-1.-overview">
<h2>1. Overview<a class="headerlink" href="#-1.-overview" title="Permalink to this headline">¶</a></h2>
<p>In Polkadot, we produce relay chain blocks using our
 <strong>B</strong>lind <strong>A</strong>ssignment for <strong>B</strong>lockchain <strong>E</strong>xtension protocol,
 abbreviated BABE.
BABE assigns blocks production slots, according to stake,
 using roughly the randomness cycle from Ouroboros Praos [2].</p>
<p>In brief, all block producers have a verifiable random function (VRF)
keys which they register with locked stake.  These VRFs produce secret
randomness which determines when they produce blocks.  A priori, there
is a risk that block producers could grind through VRF keys to bias
results, so VRF inputs must include public randomness created only
after the VRF key.  We therefore have epochs in which we create fresh
public on-chain randomness by hashing together all the VRF outputs
revealed in block creation during the epoch.  In this way, we cycle
between private but verifiable randomness and collaborative public
randomness.</p>
<p>… TODO …</p>
<p>In Ouroboros [1] and Ouroboros Praos [2], the best chain (valid chain) is the longest chain. In Ouroboros Genesis, the best chain can be the longest chain or the chain which is forked long enough and denser than the other chains in some interval.  We have a different approach for the best chain selection based on GRANDPA and longest chain.  In addition, we do not assume that all parties can access the current slot number which is more realistic assumption.</p>
</div>
<div class="section" id="-2.-babe">
<h2>2. BABE<a class="headerlink" href="#-2.-babe" title="Permalink to this headline">¶</a></h2>
<p>In BABE, we have sequential non-overlaping epochs <span class="math notranslate nohighlight">\((e_1, e_2,\ldots)\)</span>, each of which consists of a number of sequential block production slots (<span class="math notranslate nohighlight">\(e_i = \{sl^i_{1}, sl^i_{2},\ldots,sl^i_{t}\}\)</span>) up to some bound <span class="math notranslate nohighlight">\(t\)</span>.  At the beginning of an epoch, we randomly assign each block production slot to a “slot leader”, often one party or no party, but sometimes more than one party.  These assignments are initially secrets known only to the assigned slot leader themselves, but eventually they publicly claim their slots when they produce a new block in one.</p>
<p>Each party <span class="math notranslate nohighlight">\(P_j\)</span> has as <em>session key</em> containing at least two types of secret/public key pair:</p>
<ul class="simple">
<li><p>a verifiable random function (VRF) key <span class="math notranslate nohighlight">\((\skvrf_{j}, \pkvrf_{j})\)</span>, and</p></li>
<li><p>a signing key for blocks <span class="math notranslate nohighlight">\((\sksgn_j,\pksgn_j)\)</span>, possibly the same as the VRF key. </p></li>
</ul>
<p>We favor VRF keys being relatively long lived because new VRF keys cannot be used until well after creation and submission to the chain.  Yet, parties should update their associated signing keys from time to time to provide forward security against attackers who might exploit from creating slashable equivocations.  There are more details about session key available <a class="reference external" href="https://github.com/w3f/research/tree/master/docs/polkadot/keys">here</a>.</p>
<p>Each party <span class="math notranslate nohighlight">\(P_j\)</span> keeps a local set of blockchains <span class="math notranslate nohighlight">\(\mathbb{C}_j =\{C_1, C_2,..., C_l\}\)</span>.  All these chains have some common blocks, at least the genesis block, up until some height.</p>
<p>We assume that each party has a local buffer that contains the transactions to be added to blocks. All transactions in a block is validated with a transaction validation function.</p>
<div class="section" id="babe-with-grandpa-validators--approx-approx-ouroboros-praos">
<h3>BABE with GRANDPA Validators <span class="math notranslate nohighlight">\(\approx\)</span> Ouroboros Praos<a class="headerlink" href="#babe-with-grandpa-validators--approx-approx-ouroboros-praos" title="Permalink to this headline">¶</a></h3>
<p>BABE is almost the same as Ouroboros Praos [2] except chain selection rule and the slot time adjustment.</p>
<p>In BABE, all validators have same amount of stake so their probability of being selected as slot leaders is equal. Given that we have <span class="math notranslate nohighlight">\(n\)</span> validators and relative stake of each party is <span class="math notranslate nohighlight">\(\theta = 1/n\)</span>  the probability of being selected is</p>
<div class="math notranslate nohighlight">
\[p = \phi_c(\theta) = 1-(1-c)^{\theta}\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is a constant. </p>
<p>The threshold used in BABE for each validator <span class="math notranslate nohighlight">\(P_i\)</span> is </p>
<div class="math notranslate nohighlight">
\[\tau = 2^{\ell_{vrf}}\phi_c(\theta)\]</div>
<p>where <span class="math notranslate nohighlight">\(\ell_{vrf}\)</span> is the length of the VRF’s first output (randomness value).</p>
<p>BABE consists of three phases:</p>
<div class="section" id="-1.-genesis-phase">
<h4>1. Genesis Phase<a class="headerlink" href="#-1.-genesis-phase" title="Permalink to this headline">¶</a></h4>
<p>In this phase, we manually produce the unique genesis block.</p>
<p>The genesis block contain a random number <span class="math notranslate nohighlight">\(r_1\)</span> for use during the first epoch for slot leader assignments, the initial stake’s of the stake holders (<span class="math notranslate nohighlight">\(st_1, st_2,..., st_n\)</span>) and their corresponding session public keys (<span class="math notranslate nohighlight">\(\pkvrf_{1}, \pkvrf_{2},..., \pkvrf_{n}\)</span>), <span class="math notranslate nohighlight">\((\pksgn_{1}, \pksgn_{2},..., \pksgn_{n}\)</span>).</p>
<p>We might reasonably set <span class="math notranslate nohighlight">\(r_1 = 0\)</span> for the initial chain randomness, by assuming honesty of all validators listed in the genesis block.  We could use public random number from the Tor network instead however.</p>
<p>TODO: In the delay variant, there is an implicit commit and reveal phase provided some suffix of our genesis epoch consists of <em>every</em> validator producing a block and <em>all</em> produced blocks being included on-chain, which one could achieve by adjusting paramaters.</p>
</div>
<div class="section" id="-2.-normal-phase">
<h4>2. Normal Phase<a class="headerlink" href="#-2.-normal-phase" title="Permalink to this headline">¶</a></h4>
<p>We assume that each validator divided their timeline in slots after receiving the genesis block. They determine the current slot number according to their timeline. If a new validator joins to BABE after the genesis block, this validator divides his timeline into slots with the Median algorithm we give in Section 4.</p>
<p>In normal operation, each slot leader should produce and publish a block.  All other nodes attempt to update their chain by extending with new valid blocks they observe.</p>
<p>We suppose each validator <span class="math notranslate nohighlight">\(P_j\)</span> has a set of chains <span class="math notranslate nohighlight">\(\mathbb{C}_j\)</span> in the current slot <span class="math notranslate nohighlight">\(sl_k\)</span> in the epoch <span class="math notranslate nohighlight">\(e_m\)</span>.  We have a best chain <span class="math notranslate nohighlight">\(C\)</span> selected in <span class="math notranslate nohighlight">\(sl_{k-1}\)</span> by our selection scheme, and the length of <span class="math notranslate nohighlight">\(C\)</span> is <span class="math notranslate nohighlight">\(\ell\text{-}1\)</span>. </p>
<p>Each validator <span class="math notranslate nohighlight">\(P_j\)</span> produces a block if he is the slot leader of <span class="math notranslate nohighlight">\(sl_k\)</span>.  If the first output (<span class="math notranslate nohighlight">\(d\)</span>) of the following VRF is less than the threshold <span class="math notranslate nohighlight">\(\tau\)</span> then he is the slot leader.</p>
<div class="math notranslate nohighlight">
\[\vrf_{\skvrf_{j}}(r_m||sl_{k}) \rightarrow (d, \pi)\]</div>
<p>If <span class="math notranslate nohighlight">\(P_j\)</span> is the slot leader, <span class="math notranslate nohighlight">\(P_j\)</span> generates a block to be added on <span class="math notranslate nohighlight">\(C\)</span> in slot <span class="math notranslate nohighlight">\(sl_k\)</span>. The block <span class="math notranslate nohighlight">\(B_\ell\)</span> should contain the slot number <span class="math notranslate nohighlight">\(sl_{k}\)</span>, the hash of the previous block <span class="math notranslate nohighlight">\(H_{\ell\text{-}1}\)</span>, the VRF output  <span class="math notranslate nohighlight">\(d, \pi\)</span>, transactions <span class="math notranslate nohighlight">\(tx\)</span>, and the signature <span class="math notranslate nohighlight">\(\sigma = \sgn_{\sksgn_j}(sl_{k}||H_{\ell\text{-}1}||d||pi||tx))\)</span>. <span class="math notranslate nohighlight">\(P_i\)</span> updates <span class="math notranslate nohighlight">\(C\)</span> with the new block and sends <span class="math notranslate nohighlight">\(B_\ell\)</span>.</p>
<p><img alt="https://i.imgur.com/Yb0LTJN.png =250x" src="https://i.imgur.com/Yb0LTJN.png =250x" />ss</p>
<p>In any case (being a slot leader or not being a slot leader), when <span class="math notranslate nohighlight">\(P_j\)</span> receives a block <span class="math notranslate nohighlight">\(B = (sl, H, d', \pi', tx', \sigma')\)</span> produced by a validator <span class="math notranslate nohighlight">\(P_t\)</span>, it validates the block  with <span class="math notranslate nohighlight">\(\mathsf{Validate}(B)\)</span>. <span class="math notranslate nohighlight">\(\mathsf{Validate}(B)\)</span> should check the followings in order to validate the block:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(\mathsf{Verify}_{\pksgn_t}(\sigma')\rightarrow \mathsf{valid}\)</span> (signature verification),</p></li>
<li><p>if the party is the slot leader: <span class="math notranslate nohighlight">\(\mathsf{Verify}_{\pkvrf_t}(\pi', r_m||sl) \rightarrow \mathsf{valid}\)</span> and <span class="math notranslate nohighlight">\(d' &lt; \tau_t\)</span> (verification with the VRF’s verification algorithm). </p></li>
<li><p>if <span class="math notranslate nohighlight">\(P_t\)</span> did not produce another block for another chain in slot <span class="math notranslate nohighlight">\(sl\)</span> (no double signature),</p></li>
<li><p>if there exists a chain <span class="math notranslate nohighlight">\(C'\)</span> with the header <span class="math notranslate nohighlight">\(H\)</span>,</p></li>
<li><p>if the transactions in <span class="math notranslate nohighlight">\(B\)</span> are valid.</p></li>
</ul>
<p>If the validation process goes well, <span class="math notranslate nohighlight">\(P_j\)</span> adds <span class="math notranslate nohighlight">\(B\)</span> to <span class="math notranslate nohighlight">\(C'\)</span>. Otherwise, it ignores the block.</p>
<p>At the end of the slot, <span class="math notranslate nohighlight">\(P_j\)</span> decides the best chain with the chain selection rule we give in Section 3.</p>
</div>
<div class="section" id="-3.-epoch-update">
<h4>3. Epoch Update<a class="headerlink" href="#-3.-epoch-update" title="Permalink to this headline">¶</a></h4>
<p>Before starting a new epoch <span class="math notranslate nohighlight">\(e_m\)</span>, there are certain things to be completed in the current epoch <span class="math notranslate nohighlight">\(e_{m-1}\)</span>.
* Validators update
* (Session keys)
* Epoch randomness</p>
<p>If there is a validator update in BABE, this update has to be done until the end of the last block of the current epoch <span class="math notranslate nohighlight">\(e_{m-1}\)</span> so that they are able to actively participate the block production in epoch <span class="math notranslate nohighlight">\(e_{m+2}\)</span>. So, any validator update will valid in the BABE after at least two epoch’s later.</p>
<p>The new randomness for the new epoch is computed as in Ouroboros Praos [2]: Concatenate all the VRF outputs of blocks in the current epoch <span class="math notranslate nohighlight">\(e_{m-1}\)</span> (let us assume  the concatenation is <span class="math notranslate nohighlight">\(\rho\)</span>). Then the randomness in epoch <span class="math notranslate nohighlight">\(e_{m+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[r_{m+1} = H(r_{m}||m+1||\rho)\]</div>
<p>This also can be combined with VDF output to prevent little bias by the adversaries for better security bounds. BABE is secure without VDF but if we combine VDF with the randomness produced by blocks, we have better parachain allocation.</p>
</div>
</div>
</div>
<div class="section" id="-3.-best-chain-selection">
<h2>3. Best Chain Selection<a class="headerlink" href="#-3.-best-chain-selection" title="Permalink to this headline">¶</a></h2>
<p>Given a chain set <span class="math notranslate nohighlight">\(\mathbb{C}_j\)</span> an the parties current local chain <span class="math notranslate nohighlight">\(C_{loc}\)</span>, the best chain algorithm eliminates all chains which do not include the finalized block <span class="math notranslate nohighlight">\(B\)</span> by GRANDPA. Let’s denote the remaining chains by the set <span class="math notranslate nohighlight">\(\mathbb{C}'_j\)</span>. If we do not have a finalized block by GRANDPA, then we use the probabilistic finality in the best chain selection algorithm (the probabilistically finalized block is the block which is <span class="math notranslate nohighlight">\(k\)</span> block before than the last block of <span class="math notranslate nohighlight">\(C_{loc}\)</span>). </p>
<p>We do not use the chain selection rule as in Ouroboros Genesis [3] because this rule is useful for parties who become online after a period of time and do not have any  information related to current valid chain (for parties always online the Genesis rule and Praos is indistinguishable with a negligible probability). Thanks to Grandpa finality, the new comers have a reference point to build their chain so we do not need the Genesis rule.</p>
</div>
<div class="section" id="-4.-relative-time">
<h2>4. Relative Time<a class="headerlink" href="#-4.-relative-time" title="Permalink to this headline">¶</a></h2>
<p>It is important for parties to know the current slot  for the security and completeness of BABE. Therefore, we show how a party realizes the notion of slots. Here, we assume partial synchronous channel meaning that any message sent by a party arrives at most <span class="math notranslate nohighlight">\(\D\)</span>-slots later. <span class="math notranslate nohighlight">\(\D\)</span> is not an unknown parameter.</p>
<p>Each party has a local clock and this clock does not have to be synchronized with the network. When a party receives the genesis block, it stores the arrival time as <span class="math notranslate nohighlight">\(t_0\)</span> as a reference point of the beginning of the first slot. We are aware of the beginning of the first slot is not same for everyone. We assume that the maximum difference between start of the first slot is at most <span class="math notranslate nohighlight">\(\delta\)</span>. Then each party divides their timeline in slots. </p>
<p><strong>Median Algorithm:</strong> Parties who join BABE after the genesis block released or who lose notion of slot run the following protocol to obtain the current slot number with the Median Algorithm. </p>
<p>The median algorithm is run by all validators in the end of sync-epochs (we note that epoch and sync-epoch are not related). The first sync-epoch starts just after the genesis block is released. The other sync-epochs start when the slot number of the last (probabilistically) finalized block is $sl_{e} $ which is the smallest slot number such that  <span class="math notranslate nohighlight">\(sl_{e} - sl_{e-1} \geq s_{cd}\)</span> where <span class="math notranslate nohighlight">\(sl_{e_1}\)</span> is the slot number of the last finalized block in epoch <span class="math notranslate nohighlight">\(e-1\)</span>. Here, <span class="math notranslate nohighlight">\(s_{cd}\)</span> is the parameter of the chain density (CD) property which will be defined according the chain growth. If the previous epoch is the first epoch then <span class="math notranslate nohighlight">\(sl_{e-1} = 0\)</span>. We define the last finalized block as follows: Retrieve the best blockchain according to the best chain selection rule, trim the last <span class="math notranslate nohighlight">\(k\)</span> blocks of the best chain, the last block of the trimmed best chain is the last finalized block. Here, <span class="math notranslate nohighlight">\(k\)</span> is defined according to the common prefix property. </p>
<p>Each validator stores the arrival time <span class="math notranslate nohighlight">\(t_i\)</span> of valid blocks constantly. At the end of a sync-epoch <span class="math notranslate nohighlight">\(e\)</span>,  validators retrieve the arrival time <span class="math notranslate nohighlight">\(t_i\)</span> of only finalized blocks that belong to the sync-epoch <span class="math notranslate nohighlight">\(e\)</span>. At the end of a sync-epoch, each validator retrieves the arrival times of valid and finalized blocks which has a slot number <span class="math notranslate nohighlight">\(sl_x\)</span> where <span class="math notranslate nohighlight">\(sl_{e-1} &lt; sl_x \leq sl_{e}\)</span>. Let’s assume that there are <span class="math notranslate nohighlight">\(n\)</span>  such blocks that belong to the current sync-epoch. Then, a validator selects a slot number $ sl &gt; sl_e $ and runs the median algorithm which works as follows:</p>
<p>Let us denote the stored arrival times of blocks in the current sync-epoch by <span class="math notranslate nohighlight">\(t_1,t_2,...,t_n\)</span> whose slot numbers are <span class="math notranslate nohighlight">\(sl_1,sl_2,...,sl_n\)</span>, respectively. Remark that these slot numbers do not have to be consecutive since some slots may be empty, with multiple slot leaders or the slot leader is offline, late or early. After storing <span class="math notranslate nohighlight">\(n\)</span> arrival times, <span class="math notranslate nohighlight">\(P_j\)</span> sorts the following list <span class="math notranslate nohighlight">\(\{t_1+a_1T, t_2+a_2T,..., t_n+a_nT_\}\)</span> where <span class="math notranslate nohighlight">\(a_i = sl - sl_i\)</span>. Here, <span class="math notranslate nohighlight">\(sl\)</span> is a slot number that <span class="math notranslate nohighlight">\(P_j\)</span> wants to learn at what time it corresponds in his local time. At the end. <span class="math notranslate nohighlight">\(P_j\)</span>  outputs the median of the ordered list as (<span class="math notranslate nohighlight">\(t\)</span>) and <span class="math notranslate nohighlight">\(sl\)</span>. </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">a_i</span> <span class="o">=</span> <span class="n">sl</span> <span class="o">-</span> <span class="n">sl_i</span>
    <span class="n">store</span> <span class="n">t_i</span> <span class="o">+</span> <span class="n">a_i</span> <span class="o">*</span> <span class="n">T</span> <span class="n">to</span> <span class="n">lst</span>
<span class="n">lst</span> <span class="o">=</span> <span class="n">sort</span> <span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="k">return</span> <span class="n">median</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="https://i.imgur.com/yGYw9CL.png" src="https://i.imgur.com/yGYw9CL.png" /></p>
<p><strong>Lemma 1:</strong> Asuming that <span class="math notranslate nohighlight">\(\delta\)</span> is the maximum network delay, the maximum difference between start time of a slot  <span class="math notranslate nohighlight">\(sl' - sl \leq \delta\)</span> with the median algorithm where <span class="math notranslate nohighlight">\(sl'\)</span> the correct slot number of time <span class="math notranslate nohighlight">\(t\)</span> with the probability <span class="math notranslate nohighlight">\(p_{cp}\)</span>. </p>
<p><strong>Proof Sketch:</strong> Since all validators run the median algorithm with the arrival time of the same blocks, the difference between the output of the median algorithm of each validator differs at most <span class="math notranslate nohighlight">\(\delta\)</span>. </p>
<p><strong>Lemma 1:</strong> Assuming that the maximum total drift on clocks between sync-epochs is at most <span class="math notranslate nohighlight">\(\Sigma\)</span> and <span class="math notranslate nohighlight">\(2\delta + 2|\Sigma| \leq \theta\)</span>, the maximum difference between the new start time of a slot <span class="math notranslate nohighlight">\(sl\)</span> and the old start time of <span class="math notranslate nohighlight">\(sl\)</span> is at most <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p><strong>Proof Sketch:</strong> It comes from the fact the property that with <span class="math notranslate nohighlight">\(s_{sd}\)</span> slot we can guarantee that majority of finalized blocks produced by honest parties. Becuase of this the selected block by the median algorithm should have been sent in a time compatiple with honest clocks. </p>
<p>Having <span class="math notranslate nohighlight">\(\theta\)</span> small enough is important not to slow down the block production mechanism a while after a sync-epoch. For example, (a very extreme example)  we do not want to end up with a new clock that says that we are in the year 2001 even if we are in 2019. In this case, validators may wait 18 years to execute an action that is supposed to be done in 2019. </p>
</div>
<div class="section" id="-5.-security-analysis">
<h2>5. Security Analysis<a class="headerlink" href="#-5.-security-analysis" title="Permalink to this headline">¶</a></h2>
<p>(If you are interested in parameter selection based on the security analysis, you can directly go to the next section)
BABE is the same as Ouroboros Praos except the chain selection rule and  slot time extraction. Therefore, we need a new security analysis. </p>
<div class="section" id="definitions">
<h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<p>We give the definitions of  security properties before jumping to proofs.</p>
<p><strong>Definition 1 (Chain Growth (CG)) [1,2]:</strong> Chain growth with parameters <span class="math notranslate nohighlight">\(\tau \in (0,1]\)</span> and <span class="math notranslate nohighlight">\(s \in \mathbb{N}\)</span> ensures that if the best chain owned by an honest party at the onset of some slot <span class="math notranslate nohighlight">\(sl_u\)</span> is <span class="math notranslate nohighlight">\(C_u\)</span>, and the best chain owned by a honest party at the onset of slot <span class="math notranslate nohighlight">\(sl_v \geq sl_v+s\)</span> is <span class="math notranslate nohighlight">\(C_v\)</span>, then the difference between the length of <span class="math notranslate nohighlight">\(C_v\)</span> and <span class="math notranslate nohighlight">\(C_u\)</span> is greater or equal than/to <span class="math notranslate nohighlight">\(\tau s\)</span>.</p>
<p><strong>Definition 2 (Chain Quality (CQ)) [1,2]:</strong> Chain quality with parameters <span class="math notranslate nohighlight">\(\mu \in (0,1]\)</span> and <span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span> ensures that the ratio of honest blocks in any <span class="math notranslate nohighlight">\(k\)</span> length portion of an honest chain is <span class="math notranslate nohighlight">\(\mu\)</span>. </p>
<p><strong>Definition 3 (Common Prefix)</strong> Common prefix with parameters <span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span> ensures that any chains <span class="math notranslate nohighlight">\(C_1, C_2\)</span> possessed by two honest parties at the onset of the slots <span class="math notranslate nohighlight">\(sl_1 &lt; sl_2\)</span> are such satisfies <span class="math notranslate nohighlight">\(C_1^{\ulcorner k} \leq C_2\)</span> where  <span class="math notranslate nohighlight">\(C_1^{\ulcorner k}\)</span> denotes the chain obtained by removing the last <span class="math notranslate nohighlight">\(k'\)</span> blocks from <span class="math notranslate nohighlight">\(C_1\)</span>, and <span class="math notranslate nohighlight">\(\leq\)</span> denotes the prefix relation.</p>
<p>We define a new and stronger conmmon prefix property since we have a chance to finalize blocks earlier (smaller <span class="math notranslate nohighlight">\(k\)</span>) than the probabilistic finality that Ouroboros Praos [2] provides thanks to GRANDPA.</p>
<p><strong>Definition 4: (Strong Common Prefix (SCP))</strong> Assuming that the common prefix property is satisfied with parameter <span class="math notranslate nohighlight">\(k\)</span>, strong common prefix  with parameter <span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span> ensures that there exists <span class="math notranslate nohighlight">\(k' &lt; k\)</span> and a slot number <span class="math notranslate nohighlight">\(sl_1\)</span> such that for any two chain <span class="math notranslate nohighlight">\(C_1,C_2\)</span> possessed by two honest parties at the onset of <span class="math notranslate nohighlight">\(sl_1\)</span> and <span class="math notranslate nohighlight">\(sl_2\)</span> where <span class="math notranslate nohighlight">\(sl_1 &lt; sl_2\)</span>, <span class="math notranslate nohighlight">\(C_1^{\ulcorner k'} \leq C_2\)</span>.</p>
<p>In a nutshell, strong common prefix property ensures that there is a least one block which is finalized earlier than other blocks. </p>
<p>It has been shown [4] that the persistence and liveness is satisfied if the block production ensure chain growth, chain quality and common prefix proerties. <strong>Persistence</strong> ensures that, if a transaction is seen in a block deep enough in the chain, it will stay there and <strong>liveness</strong> ensures that if a transaction is given as input to all honest players, it will eventually be inserted in a block, deep enough in the chain, of an honest player.</p>
</div>
<div class="section" id="security-proof-of-babe">
<h3>Security Proof of BABE<a class="headerlink" href="#security-proof-of-babe" title="Permalink to this headline">¶</a></h3>
<p>We first prove that BABE satisfies chain growth, chain quality and strong common prefix properties in one epoch. Second, we prove that BABE’s secure by showing that BABE satisfies persistence and liveness in multiple epochs. </p>
<p>Before starting the security analysis, we give probabilities of being selected as a slot leader [2] or noone selected. We use the notations <span class="math notranslate nohighlight">\(sl = \bot\)</span> if a slot <span class="math notranslate nohighlight">\(sl\)</span> is empty,  <span class="math notranslate nohighlight">\(sl = 0_{L}\)</span> if <span class="math notranslate nohighlight">\(sl\)</span> is given to only one late honest party (<span class="math notranslate nohighlight">\(\D\)</span> behind the current slot) and <span class="math notranslate nohighlight">\(sl = 0_S\)</span>  if <span class="math notranslate nohighlight">\(sl\)</span> is given to only one synchronized honest party.</p>
<div class="math notranslate nohighlight">
\[p_\bot=\mathsf{Pr}[sl = \bot] = \prod_{i\in \mathcal{P}}1-\phi(\alpha_i) = \prod_{i \in \mathcal{P}} (1-c)^{\alpha_i} = 1-c\]</div>
<div class="math notranslate nohighlight">
\[p_{0_L} = \sum_{i\in\mathcal{H}_L}\phi(\alpha_i)(1-\phi(1-\alpha_i)) = \sum_{i\in\mathcal{H}_L}(1-(1-c)^{\alpha_i})(1-c)^{1-\alpha_i}\]</div>
<p>similarly,
<span class="math notranslate nohighlight">\(p_{0_S} = \sum_{i\in\mathcal{H}_S}(1-(1-c)^{\alpha_i})(1-c)^{1-\alpha_i}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(\mathcal{P}\)</span> is the set of indexes of all parties, <span class="math notranslate nohighlight">\(\mathcal{H}_L\)</span> is the set of indexes of all late and honest parties, <span class="math notranslate nohighlight">\(\mathcal{H}_S\)</span> is the set of indexes of all honest and synchronized parties with using Proposition 1 in [2]. </p>
<p>We can bound <span class="math notranslate nohighlight">\(p_{0_S}\)</span> and <span class="math notranslate nohighlight">\(p_{0_L}\)</span> as <span class="math notranslate nohighlight">\(p_{0_S} \geq \phi(\alpha_S)(1-c) \geq \alpha_Sc(1-c)\)</span> and <span class="math notranslate nohighlight">\(p_{0_L} \geq \phi(\alpha_L)c(1-c)\geq \alpha_L(1-c)\)</span> where <span class="math notranslate nohighlight">\(\alpha_S\)</span> denotes the total relative stake of synchronized and honest parties and <span class="math notranslate nohighlight">\(\alpha_L\)</span> denotes the total relative stake of honest and late parties. For the rest, we denote <span class="math notranslate nohighlight">\(\alpha = \alpha_S + \alpha_L = \gamma\alpha + \beta\alpha\)</span> where <span class="math notranslate nohighlight">\(\gamma + \beta = 1\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> is the relative stakes of honest parties.</p>
<p>In Lemma 1 and Lemma 2, we prove that a late party can be at most <span class="math notranslate nohighlight">\(\D\)</span> behind of the current slot. If a late party is a slot leader then his block is added to the best chain if there are at least <span class="math notranslate nohighlight">\(2\D\)</span> consecutive empty slots because he sends his block <span class="math notranslate nohighlight">\(\D\)</span> times later and his block may be received <span class="math notranslate nohighlight">\(\D\)</span> times later by other honest parties becuase of the network delay. Having late parties in BABE influences chain growth. </p>
<p><strong>Theorem 1 (CG):</strong> Let <span class="math notranslate nohighlight">\(k, R, \D \in \mathbb{N}\)</span> and let <span class="math notranslate nohighlight">\(\alpha = \alpha_S + \alpha_L = \gamma\alpha + \beta\alpha\)</span> is the total relative stake of honest parties. Then, the probability that an adversary <span class="math notranslate nohighlight">\(\A\)</span> makes BABE violate the chain growth property (Definition 1) with parameters <span class="math notranslate nohighlight">\(s \geq 6 \D\)</span> and <span class="math notranslate nohighlight">\(\tau = \frac{\lambda c\alpha(\gamma+ \lambda \beta)}{6}\)</span> throughout a period of <span class="math notranslate nohighlight">\(R\)</span> slots, is no more than <span class="math notranslate nohighlight">\(2\D Rc  \exp({-\frac{(s-5\D)\lambda c\alpha(\gamma+ \lambda \beta)}{16\D}})\)</span>, where c denotes the constant <span class="math notranslate nohighlight">\(\lambda = (1-c)^{\D}\)</span>.</p>
<p><strong>Proof:</strong> We define two types of slot. We call a slot <em><span class="math notranslate nohighlight">\(2\D\)</span>-right isolated</em> if the slot leader is one late party and the next <span class="math notranslate nohighlight">\(2\D - 1\)</span> slots are empty (no party is assigned). We call a slot <em><span class="math notranslate nohighlight">\(\D\)</span>-right isolated</em> if the slot leader is only one synchronized honest party (not late party) and the next consecutive <span class="math notranslate nohighlight">\(\D-1\)</span> slots are empty. </p>
<p>Now consider a chain owned by an honest party in <span class="math notranslate nohighlight">\(sl_u\)</span> and a chain owned by an honest party in <span class="math notranslate nohighlight">\(sl_v \geq sl_u + s\)</span>. We need to show that honest parties’ blocks are added most of times between <span class="math notranslate nohighlight">\(sl_u\)</span> and <span class="math notranslate nohighlight">\(sl_v\)</span>. Therefore, we need to find the expected number of <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated slots between <span class="math notranslate nohighlight">\(sl_u\)</span> and <span class="math notranslate nohighlight">\(sl_v\)</span>  given that the relative stake of late parties is <span class="math notranslate nohighlight">\(\alpha_L = \beta \alpha\)</span> and expected number of <span class="math notranslate nohighlight">\(\D\)</span>-right isolated slots given that the relative stake of synchronized honest parties is <span class="math notranslate nohighlight">\(\alpha_S = \gamma\alpha\)</span>. Remark that a slot can be either <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated or <span class="math notranslate nohighlight">\(\D\)</span>-right isolated or neither of them.</p>
<p>Consider the chains <span class="math notranslate nohighlight">\(C_u\)</span> and <span class="math notranslate nohighlight">\(C_v\)</span> in slots <span class="math notranslate nohighlight">\(sl_u\)</span> and <span class="math notranslate nohighlight">\(sl_v\)</span> owned by the honest parties, respectively where <span class="math notranslate nohighlight">\(sl_u\)</span> is the first slot of the epoch. We can guarantee that <span class="math notranslate nohighlight">\(C_u\)</span> is one of the chains of everyone in <span class="math notranslate nohighlight">\(sl_u + 2\D\)</span> and the chain <span class="math notranslate nohighlight">\(C_v\)</span> is one of the chains of everyone if it is sent in slot <span class="math notranslate nohighlight">\(sl_v - 2\D\)</span>. Therefore, we are interested in slots between <span class="math notranslate nohighlight">\(sl_u + 2\D\)</span> and <span class="math notranslate nohighlight">\(sl_v - 2\D\)</span>. Let us denote the set of these slots by <span class="math notranslate nohighlight">\(S = \{sl_u + 2\D, sl_u+2\D+1,...,sl_v-2\D\}\)</span>. Remark that <span class="math notranslate nohighlight">\(|S| = s-4\D\)</span>.</p>
<p>Now, we define a random variable <span class="math notranslate nohighlight">\(X_t \in \{0,1\}\)</span> where <span class="math notranslate nohighlight">\(t\in S\)</span>. <span class="math notranslate nohighlight">\(X_t = 1\)</span> if <span class="math notranslate nohighlight">\(t\)</span> is <span class="math notranslate nohighlight">\(2\D\)</span> or <span class="math notranslate nohighlight">\(\D\)</span>-right isolated with respect to the probabilities <span class="math notranslate nohighlight">\(p_\bot, p_{0_L}, p_{0_S}\)</span>. Then 
<span class="math notranslate nohighlight">\(\mu = \mathbb{E}[X_t] = p_{0_S}p_\bot^{\D-1}+p_{0_L}p_\bot^{2\D-1} \geq \alpha_Sc(1-c)^{\D}+\alpha_Lc(1-c)^{2\D}.\)</span></p>
<p>With <span class="math notranslate nohighlight">\( \lambda = (1-c)^{\D}\)</span>, <span class="math notranslate nohighlight">\(\alpha = \alpha_L+\alpha_S = \beta\alpha+ \gamma \alpha\)</span>,</p>
<div class="math notranslate nohighlight">
\[\mu \geq \lambda c\alpha(\gamma+ \lambda  \beta)\]</div>
<p>Remark that <span class="math notranslate nohighlight">\(X_t\)</span> and <span class="math notranslate nohighlight">\(X_{t'}\)</span> are independent if <span class="math notranslate nohighlight">\(|t-t'| \geq 2\D\)</span>. Therefore, we define <span class="math notranslate nohighlight">\(S_z = \{t\in S: t \equiv z \text{ mod }2\D\}\)</span> where all <span class="math notranslate nohighlight">\(X_t\)</span> indexed by <span class="math notranslate nohighlight">\(S_z\)</span> are independent and <span class="math notranslate nohighlight">\(|S_z| &gt;  \frac{s-5\D}{2\D}\)</span>.</p>
<p>We apply a <a class="reference external" href="http://math.mit.edu/~goemans/18310S15/chernoff-notes.pdf">Chernoff Bound</a> to each <span class="math notranslate nohighlight">\(S_z\)</span> with <span class="math notranslate nohighlight">\(\delta = 1/2\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathsf{Pr}[\sum_{t \in S_z}X_t &lt; |S_z|\mu/2] \leq e^{-\frac{|S_z|\mu}{8}}\leq e^{-\frac{(s-4\D)\mu}{16\D}}\]</div>
<p>Recall that we want to bound the number of <span class="math notranslate nohighlight">\(2\D\)</span> and <span class="math notranslate nohighlight">\(\D\)</span>-right isolated slots. Let’s call this number <span class="math notranslate nohighlight">\(H\)</span>. If for all <span class="math notranslate nohighlight">\(z\)</span>, <span class="math notranslate nohighlight">\(\sum_{t \in S_z}X_t \geq |S_z|\mu/2\)</span>, then <span class="math notranslate nohighlight">\(H = \sum_{t\in S} X_t \geq |S|\mu/2\)</span>. With union bound</p>
<div class="math notranslate nohighlight">
\[\mathsf{Pr}[H &lt; |S|\mu/2] \leq 2\D e^{-\frac{(s-5\D)\mu}{16\D}}\]</div>
<p>since <span class="math notranslate nohighlight">\(\mu \geq \lambda c\alpha(\gamma+  \beta)\)</span></p>
<div class="math notranslate nohighlight">
\[\mathsf{Pr}[H &lt; |S|\frac{\lambda c\alpha(\gamma+ \lambda \beta)}{2}] \leq \mathsf{Pr}[H &lt; |S|\mu/2]\leq 2\D \exp({-\frac{(s-5\D)\lambda c\alpha(\gamma+ \lambda \beta)}{16\D}})\space\space\space (2)\]</div>
<p>We find that in the first <span class="math notranslate nohighlight">\(s\)</span> slot of an epoch the chain grows <span class="math notranslate nohighlight">\(\tau s\)</span> block with the probability given in (2). Now consider the chain growth from slot <span class="math notranslate nohighlight">\(sl_{u+1}\)</span> to <span class="math notranslate nohighlight">\(sl_{v+1}\)</span>. We know that the chain grows at least <span class="math notranslate nohighlight">\(\tau s -1\)</span> blocks between <span class="math notranslate nohighlight">\(sl_{u+1}\)</span> to <span class="math notranslate nohighlight">\(sl_v\)</span>. So, the chain grows one block for sure if <span class="math notranslate nohighlight">\(sl_{v+1}\)</span> is <span class="math notranslate nohighlight">\(\D\)</span> or <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated which with probability <span class="math notranslate nohighlight">\(\alpha f c(\gamma+c\beta)\)</span>.  

If we apply the same for each <span class="math notranslate nohighlight">\(sl &gt; sl_u\)</span> we obtain</p>
<div class="math notranslate nohighlight">
\[2\D R \alpha \lambda  c(\gamma+\lambda\beta) \exp({-\frac{(s-5\D)\lambda c\alpha(\gamma+ \lambda \beta)}{16\D}})\]</div>
<p>given <span class="math notranslate nohighlight">\(|S| = s-4\D\)</span> and if <span class="math notranslate nohighlight">\(s \geq 6\D\)</span>, <span class="math notranslate nohighlight">\(|S| \geq \frac{s}{3}\)</span> (<span class="math notranslate nohighlight">\(\tau s = \frac{\lambda c\alpha(\gamma+ \lambda \beta)}{6}s \geq \frac{\lambda c\alpha(\gamma+ \lambda \beta)}{2}|S|\)</span>). </p>
<div class="math notranslate nohighlight">
\[\tag*{\(\blacksquare\)}\]</div>
<p><strong>Theorem 2 (CQ):</strong> Let <span class="math notranslate nohighlight">\(k,\D \in \mathbb{N}\)</span> and <span class="math notranslate nohighlight">\(\epsilon \in (0,1)\)</span>. Let <span class="math notranslate nohighlight">\(\alpha(\gamma+(1-c)^\D\beta)(1-c)^\D \geq (1+\epsilon)/2\)</span> where <span class="math notranslate nohighlight">\(\alpha = \alpha_S+\alpha_L = \gamma\alpha + \beta\alpha\)</span> is the relative stake of honest parties. Then, the probability of an adversary <span class="math notranslate nohighlight">\(\A\)</span> whose relative stake is at most <span class="math notranslate nohighlight">\(1-\alpha\)</span> violate the chain growth property (Definition 2) with parammeters <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(\mu = 1/k\)</span> in <span class="math notranslate nohighlight">\(R\)</span> slots with probability at most <span class="math notranslate nohighlight">\(Re^{-\Omega(k)}\)</span>.</p>
<p><strong>Proof (sketch):</strong> The proof is very similar to the proof in [2]. It is based on the fact that the number of <span class="math notranslate nohighlight">\(2\D\)</span> and <span class="math notranslate nohighlight">\(\D\)</span> isolated slots are more than normal slots because of the assumption <span class="math notranslate nohighlight">\((\alpha(\gamma+(1-c)^\D\beta)(1-c)^\D \geq (1+\epsilon)/2\)</span>. Remark that probability of having <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated slot is <span class="math notranslate nohighlight">\(\alpha\beta(1-c)^{2\D}\)</span>, having <span class="math notranslate nohighlight">\(\D\)</span>-right isolated slot is <span class="math notranslate nohighlight">\(\alpha\gamma(1-c)^{\D}\)</span> and sum of them are greater than 1/2 because of the assumption. </p>
<div class="math notranslate nohighlight">
\[\tag*{\(\blacksquare\)}\]</div>
<p><strong>Theorem 3 (SCP):</strong> Let <span class="math notranslate nohighlight">\(k,\D \in \mathbb{N}\)</span> and <span class="math notranslate nohighlight">\(\epsilon \in (0,1)\)</span>. Let <span class="math notranslate nohighlight">\(\alpha(\gamma+(1-c)^\D\beta)(1-c)^\D \geq (1+\epsilon)/2\)</span> where <span class="math notranslate nohighlight">\(\alpha = \alpha_S+\alpha_L = \gamma\alpha + \beta\alpha\)</span> is the relative stake of honest parties. Assuming that the GRANDPA finality gadget finalizes a block at most <span class="math notranslate nohighlight">\(\kappa\)</span> slots later with the probability <span class="math notranslate nohighlight">\(\theta\)</span>, then the probability of an adversary <span class="math notranslate nohighlight">\(\A\)</span> whose relative stake is at most <span class="math notranslate nohighlight">\(1-\alpha_L+\alpha_S\)</span> violate the <strong>strong</strong> common prefix property with parammeter <span class="math notranslate nohighlight">\(k\)</span> in <span class="math notranslate nohighlight">\(R\)</span> slots with probability at most <span class="math notranslate nohighlight">\((\theta Rc^{k+1}(1-c)^{\kappa - k} + (1-\theta))\exp(\ln R +  − \Omega(k-2\D))\)</span>.</p>
<p><strong>Proof Sketch:</strong> First of all, we need to show that common prefix prefix property is satisfied with the honest relative-stake assumption. With a similar proof in [2] in Theorem 5, we can conclude that the common prefix property can be violated with the probability at most <span class="math notranslate nohighlight">\(\exp(\ln R +  − \Omega(k-2\D))\)</span>. </p>
<p>SCP property is violated if there is no  two chain <span class="math notranslate nohighlight">\(C_1,C_2\)</span> at any slot number <span class="math notranslate nohighlight">\(sl_1\)</span> such that <span class="math notranslate nohighlight">\(C_1^{\ulcorner k'} \leq C_2\)</span> and <span class="math notranslate nohighlight">\(k'\leq k\)</span> where <span class="math notranslate nohighlight">\(C_2\)</span> is a chain of an honest party in slot <span class="math notranslate nohighlight">\(sl_2&gt;sl_1\)</span>. If <span class="math notranslate nohighlight">\(\kappa\)</span> slots later, the chain grows more than <span class="math notranslate nohighlight">\(k\)</span>, then the probabilistic finality passes the GRANDPA finality gadget. So, if for all <span class="math notranslate nohighlight">\(\kappa\)</span> slots after a non-empty slot, the chains grows more than <span class="math notranslate nohighlight">\(k\)</span> or the GRANDPA finality gadget finalize a block after <span class="math notranslate nohighlight">\(\kappa\)</span> slots then strong common prefix proerty is violated given that the GRANDPA finality gadget finalizes a block at most    <span class="math notranslate nohighlight">\(\kappa\)</span> slots later with the probability <span class="math notranslate nohighlight">\(\theta\)</span>. This happens with at least the probability <span class="math notranslate nohighlight">\(\theta Rc^{k+1}(1-c)^{\kappa - k} + (1-\theta)\)</span> in <span class="math notranslate nohighlight">\(R\)</span> slots. </p>
<div class="math notranslate nohighlight">
\[\tag*{\(\blacksquare\)}\]</div>
<p>Remark than even if <span class="math notranslate nohighlight">\(\theta = 0\)</span>, we still have the common prefix property as in Ouroboros Praos [2].</p>
<p><strong>Theorem 4 (Persistence and Liveness):</strong> Fix parameters <span class="math notranslate nohighlight">\(k, R, \D, L \in \mathbb{N}\)</span>, <span class="math notranslate nohighlight">\(\epsilon \in (0,1)\)</span> and <span class="math notranslate nohighlight">\(r\)</span>. Let <span class="math notranslate nohighlight">\(R \geq 12k/c(1+\epsilon)\)</span> be the epoch length, <span class="math notranslate nohighlight">\(L\)</span> is the total lifetime of the system and <span class="math notranslate nohighlight">\(\alpha(\gamma+(1-c)^\D\beta)(1-c)^\D \geq (1+\epsilon)/2\)</span>
BABE satisfies persitence [2] with parameters <span class="math notranslate nohighlight">\(k\)</span> and liveness with parameters <span class="math notranslate nohighlight">\(s \geq  12k/c(1+\epsilon)\)</span> with probability <span class="math notranslate nohighlight">\(1-\exp({\ln L\D c-\Omega(k-\ln tqk)})\)</span> where <span class="math notranslate nohighlight">\(r= 8tqk/(1+\epsilon)\)</span> is the resetting power of the adversary during the randomness generation.</p>
<p><strong>Proof (Sketch):</strong> The proof is very similar to Theorem 9 in [2]. The idea is as follows: The randomness for the next epoch is resettable until  the end of the epoch <span class="math notranslate nohighlight">\(R/c(1+\epsilon) &gt; 12k/c(1+\epsilon)\)</span>. Now let’s check the chain growth in <span class="math notranslate nohighlight">\(s = 12k/c(1+\epsilon)\)</span> with <span class="math notranslate nohighlight">\(\tau= \frac{\lambda c\alpha(\gamma+ \lambda \beta)}{6}\)</span> where <span class="math notranslate nohighlight">\(\lambda = (1-c)^\D\)</span>.</p>
<div class="math notranslate nohighlight">
\[\tau s = \frac{(1-c)^\D c\alpha(\gamma+ (1-c)^{\D} \beta)}{6}\frac{12k}{c(1+\epsilon)} \geq k \]</div>
<p>The stake distribution (for epoch <span class="math notranslate nohighlight">\(e_{j+3}\)</span>) which is updated until the end of epoch <span class="math notranslate nohighlight">\(e_j\)</span> is finalized at latest in the last slot <span class="math notranslate nohighlight">\(12k/c(1+\epsilon)\)</span> of epoch <span class="math notranslate nohighlight">\(e_{j+1}\)</span>. So it is finalized before the randomness of the epoch (<span class="math notranslate nohighlight">\(e_{j+3}\)</span>) generated. In addition to this, the chain growth property shows that there will be at least one honest block in the first <span class="math notranslate nohighlight">\(12k/c(1+\epsilon)\)</span> slots. These two imply that the adversary cannot adapt validators’ in or out according to the random number for the epoch <span class="math notranslate nohighlight">\(e_{j+3}\)</span> and this random number provides good randomness for the epoch even though the adversary has capability of resetting <span class="math notranslate nohighlight">\(r = 8tkq/(1+\epsilon)\)</span> times (<span class="math notranslate nohighlight">\(t\)</span> is the number of corrupted parties and <span class="math notranslate nohighlight">\(q\)</span> is the maximum number of random-oracle queries for a party). So, the common prefix property still preserved with the dynamic update. Therefore, we can conclude that persistence is satisfied thanks to the common prefix property of dynamic stake with the probability (comes from Theorem 1) <span class="math notranslate nohighlight">\(2r\D Lf \exp({-\frac{(s-5\D)(1-c)^\D c\alpha(\gamma+ (1-c)^\D\beta)}{16\D}}) \space\space\space (3).\)</span> If we use the assumptions we can simplify this probability as <span class="math notranslate nohighlight">\(\exp({\ln L\D c-\Omega(k-\ln tqk)}\)</span>.
Liveness is the result of the chain growth and chain quality properties.
<span class="math notranslate nohighlight">\(\tag*{\(\blacksquare\)}\)</span></p>
<p><strong>These results are valid assuming that the signature scheme with account key is  EUF-CMA (Existentially Unforgible Chosen Message Attack) secure, the signature scheme with the session key is forward secure, and VRF realizing is realizing the functionality defined in [2].</strong></p>
<p><strong>Analysis With VDF:</strong> TODO</p>
<p>If we use VDF in the randomness update for the next epoch, <span class="math notranslate nohighlight">\(r = \mathsf{log}tkq\)</span> disappers in <span class="math notranslate nohighlight">\(p_{sec}\)</span> because we have completely random value which do not depend on hashing power of the adversary.</p>
</div>
</div>
<div class="section" id="-6.-practical-results">
<h2>6. Practical Results<a class="headerlink" href="#-6.-practical-results" title="Permalink to this headline">¶</a></h2>
<p>In this section, we find parameters of BABE in order to achieve the security in BABE. In addition to this, we show block time of BABE in worst cases (big network delays, many malicious parties) and in average case.</p>
<p>We fix the life time of the protocol as <span class="math notranslate nohighlight">\(\mathcal{L}=2.5 \text{ years}  = 15768000\)</span> seconds. Then we find the life time of the protocol  <span class="math notranslate nohighlight">\(L = \frac{\mathcal{L}}{T}\)</span>. We find the network delay in terms of slot number with <span class="math notranslate nohighlight">\(\lfloor \frac{D}{T}\rfloor\)</span> where <span class="math notranslate nohighlight">\(D\)</span> is the network delay in seconds. Assuming that parties send their block in the beginning of their slots, <span class="math notranslate nohighlight">\(\lfloor\rfloor\)</span> operation is the enough to compute the delay in terms of slots. </p>
<p>The parameter <span class="math notranslate nohighlight">\(c\)</span> is very critical because it specifies the number of empty slots because probability of having empty slot is <span class="math notranslate nohighlight">\(1-c\)</span>. If <span class="math notranslate nohighlight">\(c\)</span> is very small, we have a lot of empty slots and so we have longer block time. If <span class="math notranslate nohighlight">\(c\)</span> is big, we may not satisfy the  condition <span class="math notranslate nohighlight">\(\alpha(\gamma+(1-c)^\D\beta)(1-c)^\D \geq (1+\epsilon)/2\)</span> to apply the result of Theorem 4. So, we need to have a tradeoff between security and practicality. </p>
<p>We need to satisfy two conditions <span class="math notranslate nohighlight">\(\frac{1}{c}(\phi(\alpha\gamma)(1-c)^{\D-\alpha}(1-c)^{\D-1}+ \phi(\alpha\beta)(1-c)^{2\D-\alpha\beta} \geq \alpha(\gamma+(1-c)^\D\beta)(1-c)^\D &gt; 1/2\)</span> to apply the result of Theorem 4 and <span class="math notranslate nohighlight">\(\frac{1}{c}(\phi(\alpha\gamma)(1-c)^{\D-\alpha}(1-c)^{\D-1} \geq \alpha\gamma(1-c)^\D &gt; 1/2\)</span> to apply the result of Lemma 1 . Remark that the second condition implies the first one so it it enough to satistfy the second condition.  In order to find a <span class="math notranslate nohighlight">\(c\)</span> value which provide resistance against maxumum network delays, we let <span class="math notranslate nohighlight">\(\alpha = 0.65\)</span> and <span class="math notranslate nohighlight">\(\gamma = 0.8\)</span>. Given this if we  want to be secure even if we have maximum delay <span class="math notranslate nohighlight">\(D\)</span>, we need following <span class="math notranslate nohighlight">\(c\)</span> values. </p>
<ul class="simple">
<li><p>c = 0.278 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 1\)</span>,</p></li>
<li><p>c = 0.034 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 2\)</span></p></li>
<li><p>c = 0.018 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 3\)</span></p></li>
<li><p>c =  0.0125 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 4\)</span></p></li>
<li><p>c =  0.0094 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 5\)</span></p></li>
<li><p>c =  0.0076 if <span class="math notranslate nohighlight">\(\D = \lfloor \frac{D}{T}\rfloor = 6\)</span></p></li>
</ul>
<p>We compute the average block time in the case that the network delay is in average 1 second and all validators behave honestly, <span class="math notranslate nohighlight">\(gamma = 0.8\)</span>. In order to find, the probability of an unsychronized party’s block added to the best chain, we find the probability of having <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated slot meaning that the leaders are all honest and late and the next <span class="math notranslate nohighlight">\(2\D-1\)</span> slots are empty. Remark that the definitions of <span class="math notranslate nohighlight">\(2\D\)</span> right isolated slot is more relaxed than the definition in the proof of Theorem 1 because we do not care the growth of other chains as we care in the security analysis. We compute the expected number of  <span class="math notranslate nohighlight">\(2\D\)</span>-isolated slot according to average delay (1 sec) even though we use the secure <span class="math notranslate nohighlight">\(c\)</span> value to have maximum network resistance. So, $\D = <span class="math notranslate nohighlight">\(\lfloor\frac{1}{T}\rfloor\)</span> in the below computations.</p>
<p>Given a non-empty slot, the probability that this slot is <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated slot is
<span class="math notranslate nohighlight">\(p_{H_L} \geq \frac{\phi(\alpha\beta)(1-c)^{1-\alpha\beta}}{c}(1-c)^{2\D-1}.\)</span></p>
<p>The expected number of non-empty slot in <span class="math notranslate nohighlight">\(L\)</span> is <span class="math notranslate nohighlight">\(Lc\)</span>. So, the expected number of  <span class="math notranslate nohighlight">\(2\D\)</span>-right isolated slot in <span class="math notranslate nohighlight">\(Lc\)</span> slot is
<span class="math notranslate nohighlight">\(\mathbb{E} = Lcp_{H_S}.\)</span> Then, the block time <span class="math notranslate nohighlight">\(T_{block} \leq \frac{LT}{\mathbb{E}} = \frac{T}{c p_{H_S}}\)</span>. </p>
<p>We give graphs for required slot time to have the block time in <span class="math notranslate nohighlight">\((-1,+1)\)</span>-neighborhood of the time in the x-axis with different maximum network delay (<span class="math notranslate nohighlight">\(D = 1,2,3,4,5,6\)</span> seconds) resistance. Slot time being 0 in the graphs means is that it is not possible to have the corresponding block time.</p>
<p><img alt="https://i.imgur.com/Sz2iRE1.png" src="https://i.imgur.com/Sz2iRE1.png" /></p>
<p>If we decide to be resistant 6 seconds delay, we can choose <span class="math notranslate nohighlight">\(T = 3.905\)</span> and have around 14 seconds block time if the average network delay is 1 second. In this case, the epoch length has to be around 4.5 hours to make sure that we have a good randomness and <span class="math notranslate nohighlight">\(k = 96\)</span>. If GRANDPA works well the epoch length can be around half of 4.5 hours.</p>
<p>If we decide to be resistant 4 seconds delay, we can choose $T = 2.78   $ and have around 10 seconds block time if the average network delay is 1 second. In this case, the epoch length has to be around 3.2 hours to make sure that we have a good randomness and <span class="math notranslate nohighlight">\(k = 97\)</span>. If GRANDPA works well the epoch length can be around half of 3.2 hours.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>[1] Kiayias, Aggelos, et al. “Ouroboros: A provably secure proof-of-stake blockchain protocol.” Annual International Cryptology Conference. Springer, Cham, 2017.</p>
<p>[2] David, Bernardo, et al. “Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain.” Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, Cham, 2018.</p>
<p>[3] Badertscher, Christian, et al. “Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability.” Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. ACM, 2018.</p>
<p>[4] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. Cryptology ePrint Archive, Report 2015/1019, 2015. http://eprint.iacr.org/2015/1019</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Web3 Foundation Research</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../polkadot.html">Polkadot</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html">Polkadot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Availability_and_Validity.html">Availability and Validity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GRANDPA.html">GRANDPA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ICMP.html">ICMP Scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Parachain-Allocation.html">Parachain Allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Polkadot-Runtime-Environment.html">Polkadot Runtime Environment Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Token Economics.html">Token Economics</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../BABE.html">BABE</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">BABE</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#-1.-overview">1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#-2.-babe">2. BABE</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#babe-with-grandpa-validators--approx-approx-ouroboros-praos">BABE with GRANDPA Validators <span class="math notranslate nohighlight">\(\approx\)</span> Ouroboros Praos</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#-1.-genesis-phase">1. Genesis Phase</a></li>
<li class="toctree-l6"><a class="reference internal" href="#-2.-normal-phase">2. Normal Phase</a></li>
<li class="toctree-l6"><a class="reference internal" href="#-3.-epoch-update">3. Epoch Update</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#-3.-best-chain-selection">3. Best Chain Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#-4.-relative-time">4. Relative Time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#-5.-security-analysis">5. Security Analysis</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l5"><a class="reference internal" href="#security-proof-of-babe">Security Proof of BABE</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#-6.-practical-results">6. Practical Results</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sortition.html">Sortition</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../NPoS.html">NPoS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../keys.html">Keys</a></li>
<li class="toctree-l2"><a class="reference internal" href="../networking.html">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slashing.html">Slashing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../research_team_members.html">Research Team Members</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../../polkadot.html">Polkadot</a><ul>
  <li><a href="../BABE.html">BABE</a><ul>
      <li>Previous: <a href="../BABE.html" title="previous chapter">BABE</a></li>
      <li>Next: <a href="sortition.html" title="next chapter">Sortition</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Web3 Foundation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../../_sources/polkadot/BABE/Babe.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>